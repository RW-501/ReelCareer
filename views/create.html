<!DOCTYPE html>
<html lang="en">
  <head>
    <!-- Basic Meta Tags -->
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Discover job seekers' video resumes on ReelCareer. Browse video reels, connect with candidates, and hire talent with ease.">
    <meta name="keywords" content="video resumes, job seekers, career videos, hire talent, video profiles, professional videos, job board, employment videos, ReelCareer">
    <meta name="author" content="ReelCareer">
    <meta name="robots" content="index, follow">
    <meta name="language" content="en-US">
    <meta name="geo.region" content="US-TX">
    <meta name="geo.placename" content="Dallas, Texas">

    <!-- Title -->
    <title>Explore Video Resumes | ReelCareer Job Board</title>

    <!-- Open Graph Meta Tags -->
    <meta property="og:title" content="Explore Job Seekers' Video Resumes | ReelCareer">
    <meta property="og:description" content="Watch professional video resumes and connect with top candidates on ReelCareer's job board. Simplify your hiring process.">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://www.reelcareer.co/reels">
    <meta property="og:image" content="https://www.reelcareer.co/images/sq_logo_n_BG_tie_reelx.png">
    <meta property="og:site_name" content="ReelCareer">
    <meta property="og:locale" content="en_US">

    <!-- Twitter Card Meta Tags -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@ReelCareer">
    <meta name="twitter:title" content="Discover Video Resumes | ReelCareer">
    <meta name="twitter:description" content="Browse professional video resumes, connect with candidates, and streamline your hiring process with ReelCareer.">
    <meta name="twitter:image" content="https://www.reelcareer.co/images/sq_logo_n_BG_tie_reelx.png">

  <!-- Canonical Tag for SEO -->
  <link rel="canonical" href="https://www.reelcareer.co/reels">

  <!-- Standard Favicon -->
  <link rel="icon" type="image/x-icon" href="https://www.ReelCareer.co/images/favicons/favicon.ico">

  <!-- 32x32 Favicon -->
  <link rel="icon" type="image/png" sizes="32x32" href="https://www.ReelCareer.co/images/favicons/favicon-32x32.png">

  <!-- 16x16 Favicon -->
  <link rel="icon" type="image/png" sizes="16x16" href="https://www.ReelCareer.co/images/favicons/favicon-16x16.png">

  <!-- Apple Touch Icon -->
  <link rel="apple-touch-icon" sizes="180x180" href="https://www.ReelCareer.co/images/favicons/apple-touch-icon.png">

  <!-- Android Favicon (192x192) -->
  <link rel="icon" type="image/png" sizes="192x192" href="https://www.ReelCareer.co/images/favicons/android-chrome-192x192.png">

  <!-- Chrome Favicon (512x512) -->
  <link rel="icon" type="image/png" sizes="512x512" href="https://www.ReelCareer.co/images/favicons/android-chrome-512x512.png">

   <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">
<!--
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
-->
  
   <!-- Bootstrap CSS -->
   <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">
    
    <script src="https://reelcareer.co/public/js/scripts.js"></script>
    <script src="https://reelcareer.co/public/js/loadScripts.js"></script>
   
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&family=Montserrat:wght@400;500;700&display=swap" rel="stylesheet">

    <link
    rel="stylesheet"
    href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css"
  />

  <script src="https://cdn.jsdelivr.net/npm/@ffmpeg/ffmpeg@0.10.2/ffmpeg.min.js"></script>

    <link rel="stylesheet" href="https://reelcareer.co/public/css/styles.css">
   
   
   
</head>


<body>
    <script src="https://reelcareer.co/public/js/bodyload.js"></script>
    <nav></nav>


    <nav aria-label="breadcrumb">
      <ol class="breadcrumb">
          <li id="lastBreadcrumb_profile" class="breadcrumb-item"><a href="https://reelcareer.co/views/user">Profile</a></li>
          <li id="lastBreadcrumb_messages" class="breadcrumb-item"><a href="https://reelcareer.co/views/messaging">Messages</a></li>
          <li id="lastBreadcrumb_last" class="breadcrumb-item"><a id="lastBreadcrumb_a" href="https://reelcareer.co/views/create">Create Reel</a></li>
          <li id="breadcrumb-active-title" class="breadcrumb-item active" aria-current="page">User</li>
        </ol>
    </nav>

        <style>
          /* General Styles */
          body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;

          }





#mainVideoHolder .video-details {
    display: flex;
    justify-content: space-between;
    width: 100%;
    margin-bottom: 10px;
}

#mainVideoHolder .video-details p {
    margin: 0;
    font-size: 14px;
}

#mainVideoHolder .video-upload-section {
    display: flex;
    justify-content: center;
    width: 100%;
    margin-top: 10px;
}

#mainVideoHolder #uploadButton {
    background-color: #1d72b8;
    color: white;
    border: none;
    padding: 10px;
    font-size: 16px;
    border-radius: 5px;
    cursor: pointer;
}

#mainVideoHolder #uploadButton:hover {
    background-color: #155a8a;
}
#mainVideoHolder {
      position: relative;
      width: 640px;
      height: 360px;
      margin: 20px auto;
      border: 1px solid #ccc;
    }
    #mainVideoHolder  video {
      width: 100%;
      height: 100%;
    }
    #mainVideoHolder  canvas {
      display: none;
    }
    #mainVideoHolder  .draggable {
      cursor: grab;
    }
  main  .hidden {
      display: none;
    }
        </style>
  <!-- Modal styles -->
<style>
  .modal {
    display: none;
    position: fixed;
    z-index: 1;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    overflow: auto;
    background-color: rgba(0, 0, 0, 0.4);
  }
  .modal-content {
    background-color: #fefefe;
    margin: 15% auto;
    padding: 20px;
    border: 1px solid #888;
    width: 80%;
    max-width: 400px;
  }

  main #videoContainer {
  width: 100%;
  display: block;


}


#mainVideoHolder button:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }


main #timelineContainer {
  width: 100%;
  display: block;


}
main #overlayControls {
    width: 100%;
    display: block;
}

/* CSS for showing and hiding modals */
.modal {
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.7);
  z-index: 9999;
  align-items: center;
  justify-content: center;
}

.modal.show {
  display: flex;
}



/* Improved active overlay state */
#mainVideoHolder .active {
  border: 2px solid #4CAF50;
  box-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
  transition: all 0.3s ease-in-out;
}

/* Modal animations */
.modal {
  display: none;
  opacity: 0;
  transition: opacity 0.3s ease;
}

.modal.show {
  display: block;
  opacity: 1;
}

/* Responsive Modal for smaller screens */
@media (max-width: 600px) {
  .modal-content {
    width: 90%;
    padding: 15px;
  }
}

/* Close button on the overlay */
.overlay-close-btn {
  position: absolute;
  top: 5px;
  right: 5px;
  cursor: pointer;
  background-color: #fff;
  border: none;
  font-size: 18px;
}



  .modal-content {
    background-color: #fff;
    padding: 20px;
    margin: 15% auto;
    width: 80%; max-width: 400px;
    text-align: center;
  }


  main .syncedTime {
    color: white;
    text-align: center;
    overflow: hidden;
}

#mainVideoHolder {
    position: relative;
    width: 100%;
    height: auto;
    background-color: rgb(218 218 218 / 13%);
    overflow: hidden;
    margin: auto;
    right: 0;
    left: 0;
    top: 0;
    bottom: 0;
    border-top-right-radius: 25px;
    border-top-left-radius: 25px;
    display: flex;
    flex-direction: row;
    flex-wrap: nowrap;
    align-content: space-between;
    justify-content: space-around;
    align-items: stretch;
    padding: 2rem;
}
#videoContainer {
  position: relative;
  width: 100%; /* Example size */
  height: 500px;
  overflow: hidden;
  background-color: rgba(0, 0, 0, 0.16);

}

#videoPlayer,
#videoCanvas {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  width: 100%; /* Match videoContainer width */
  height: 100%; /* Match videoContainer height */
  object-fit: contain; /* Default to 'fit' mode */
margin: auto;
}

#mainVideoHolder .actions {
    display: flex;
    justify-content: space-around;
    width: 100%;
    margin-bottom: 10px;
}

#mainVideoHolder .action-btn {
    background: transparent;
    border: none;
    color: white;
    font-size: 24px;
    cursor: pointer;
}

#mainVideoHolder .action-btn:hover {
    color: #1d72b8;
}
#videoBody {
  height: 100%;
  width: 100%;
}

#trashIcon {
margin: auto;

}

.controls {
    width: 100%;
    display: grid;
    align-content: space-between;
    justify-content: center;
    align-items: stretch;
    justify-items: stretch;
}

.controlsGroup {
    width: 100%;
    display: grid;
    align-content: stretch;
    justify-content: space-around;
    align-items: stretch;
    justify-items: stretch;
    gap: 1.5rem;
    -webkit-text-stroke: thin;
    font: icon;
}
#mainVideoHolder .flex {
    display: flex;
    flex-direction: row;
    flex-wrap: wrap;
    align-content: space-between;
    justify-content: space-between;
    align-items: center;
    gap: 2rem;
    width: 100%;
}
.controlsGroup button {
  width: auto;
  padding: 1rem;
  height: 50px;
}
</style>

<main id="main-content">
  <!-- Video Container -->
  <div id="mainVideoHolder" aria-labelledby="mainVideoHolder">

    <!-- left Controls Container -->
    <div class="controls" role="group" aria-labelledby="controls">

        <div class="controlsGroup" role="group" aria-labelledby="controlsGroup">
            <!-- Trigger Button -->
            <button id="uploadButton" aria-label="Upload a video">
                <i class="fas fa-upload" aria-hidden="true"></i> Upload Video
            </button>
        </div>

        <div class="controlsGroup flex" role="group" aria-labelledby="controlsGroup">
            <button id="fitButton" aria-label="Fit video to screen">
                <i class="fas fa-expand-arrows-alt" aria-hidden="true"></i> Fit
            </button>
            <button id="coverButton" aria-label="Cover video to screen">
                <i class="fas fa-arrows-alt" aria-hidden="true"></i> Cover
            </button>
        </div>

        <div class="controlsGroup" role="group" aria-labelledby="Video Slice & Append">
            <!-- Video Slice & Append -->
            <button id="addAudioButton" aria-label="Add audio to video">
                <i class="fas fa-volume-up" aria-hidden="true"></i> Add Audio
            </button>
            <button id="appendVideoButton" aria-label="Append video or image to the video">
                <i class="fas fa-plus-circle" aria-hidden="true"></i> Append Video/Image
            </button>
            <button id="sliceVideoButton" aria-label="Slice the video">
                <i class="fas fa-cut" aria-hidden="true"></i> Slice Video
            </button>
        </div>

    </div>

    <div id="videoContainer" aria-labelledby="videoContainer">
      <div id="videoBody">
        
        <video id="videoPlayer" controls autoplay aria-label="Video player"></video>
        <canvas id="videoCanvas" style="display: none;" aria-hidden="true"></canvas>
</div>
        <!-- Add Trash Can Icon -->
        <i
            id="trashIcon"
            class="fas fa-trash hidden"
            style="
                position: absolute;
                bottom: 20px;
                left: 50%;
                transform: translateX(-50%);
                font-size: 40px;
                color: red;
            "
            aria-label="Delete overlay"
            title="Delete Overlay"
        ></i>
    </div>

    <!-- right Controls Container -->
    <div class="controls" role="group" aria-labelledby="controls">
        <div class="controlsGroup flex" role="group" aria-labelledby="controlsGroup">
            <button id="undoButton" aria-label="Undo last action" title="Undo">
                <i class="fas fa-undo" aria-hidden="true"></i> Undo
            </button>
            <button id="redoButton" aria-label="Redo last action" title="Redo">
                <i class="fas fa-redo" aria-hidden="true"></i> Redo
            </button>
        </div>

        <div class="controlsGroup" role="group" aria-labelledby="controlsGroup">
            <!-- Overlay Controls -->
            <!-- Add Image or Text Overlays -->
            <button id="textOverlayButton" aria-label="Add a text overlay to the video">
                <i class="fas fa-font" aria-hidden="true"></i> Add Text Overlay
            </button>
            <button id="imageButton" aria-label="Add an image overlay to the video">
                <i class="fas fa-image" aria-hidden="true"></i> Add Image Overlay
            </button>
        </div>

        <div class="controlsGroup" role="group" aria-labelledby="controlsGroup">
            <button id="downloadButton" disabled aria-disabled="true" aria-label="Render and download the edited video" title="Render & Download">
                <i class="fas fa-download" aria-hidden="true"></i> Render & Download
            </button>
            <button id="previewVideoSegment" aria-label="Preview the video segment" title="Preview">
                <i class="fas fa-eye" aria-hidden="true"></i> Preview
            </button>
        </div>

    </div>

</div>

<div id="timelineDiv" style="position: relative; width: 100%; height: 50px; background: #ddd;">
    <div id="startDiv" class="syncedTime" style="position: absolute; height: 100%; width: 5%; background: black;"></div>
    <div id="stopDiv" class="syncedTime" style="position: absolute; height: 100%; width: 5%; background: red;"></div>
</div>

  
  <!-- Audio Input -->
  <!-- Hidden Video Input -->
  <input type="file" id="videoInput" accept="video/*" class="hidden" aria-label="Select a video to upload" />
  <input type="file" id="audioInput" accept="audio/*" class="hidden" title="Select an audio file to add" aria-label="Select an audio file to add" />




</main>



<!-- Text Overlay Modal -->
<div id="textOverlayModal" class="modal" role="dialog" aria-labelledby="textOverlayModalLabel">
  <div class="modal-content">
    <h3 id="textOverlayModalLabel">Add Text Overlay</h3>
    <input type="text" id="overlayTextInput" placeholder="Enter text" required aria-label="Enter text for overlay" />
    <input type="color" id="textColorInput" value="#ffffff" aria-label="Choose text color" />
    <input type="number" id="fontSizeInput" value="20" min="10" max="100" required aria-label="Choose font size" />
    <select id="fontTypeInput" aria-label="Choose font type">
      <option value="Arial">Arial</option>
      <option value="Verdana">Verdana</option>
      <option value="Tahoma">Tahoma</option>
    </select>
    <button id="saveTextOverlay" aria-label="Save text overlay">Save</button>
  </div>
</div>

<!-- Image Overlay Modal -->
<div id="imageModal" class="modal" role="dialog" aria-labelledby="imageModalLabel">
  <div class="modal-content">
    <h3 id="imageModalLabel">Add Image Overlay</h3>
    <input type="url" id="imageURLInput" placeholder="Enter image URL" aria-label="Enter image URL for overlay" />
    <button id="saveImageOverlay" aria-label="Save image overlay">Save</button>
  </div>
</div>

<!-- Edit Modal -->
<div id="editOverlayModal" class="modal" role="dialog" aria-labelledby="editOverlayModalLabel">
  <div class="modal-content">
    <h3 id="editOverlayModalLabel" class="sr-only">Edit Text Overlay</h3>
    <label for="editTextInput">Text:</label>
    <input type="text" id="editTextInput" aria-label="Edit text for overlay">
    <label for="editColorInput">Color:</label>
    <input type="color" id="editColorInput" aria-label="Edit color for overlay">
    <label for="editFontSizeInput">Font Size:</label>
    <input type="number" id="editFontSizeInput" aria-label="Edit font size for overlay">
    <button id="saveEdit" aria-label="Save changes to overlay">Save Changes</button>
    <button id="closeEditModal" aria-label="Close the edit modal">Cancel</button>
  </div>
</div>
<script>

   // Reference the button and input
   const uploadButton = document.getElementById("uploadButton");
  const videoInput = document.getElementById("videoInput");
  const downloadButton = document.getElementById("downloadButton");
  const addAudioButton = document.getElementById("addAudioButton");
  const audioInput = document.getElementById("audioInput");
  const appendButton = document.getElementById("appendVideoButton");
  const undoButton = document.getElementById("undoButton");
  const redoButton = document.getElementById("redoButton");
  const videoContainer = document.getElementById("videoContainer");

  const videoCanvas = document.getElementById("videoCanvas");
  const ctx = videoCanvas.getContext("2d");

  const videoPlayer = document.getElementById("videoPlayer");
const fitButton = document.getElementById("fitButton");
const coverButton = document.getElementById("coverButton");

// Default video settings on load
window.addEventListener("load", () => {
  setVideoSize("inherit", 500); // Set default container size
  videoPlayer.style.objectFit = "contain"; // Default to 'fit'
});

// Function to set video container and player size
function setVideoSize(width, height) {
  const videoContainer = document.getElementById("videoContainer");
  videoContainer.style.width = `${width}`;
  videoContainer.style.height = `${height}px`;
}

// Event listeners for scaling buttons
fitButton.addEventListener("click", () => {
  videoPlayer.style.objectFit = "contain"; // Fit mode
});

coverButton.addEventListener("click", () => {
  videoPlayer.style.objectFit = "cover"; // Cover mode
});
 

  // Function to set canvas size to match container
function setCanvasSize() {
  videoCanvas.width = videoContainer.offsetWidth;
  videoCanvas.height = videoContainer.offsetHeight;
}

// Set canvas size on load and resize
window.addEventListener("load", setCanvasSize);
window.addEventListener("resize", setCanvasSize);

  let mediaRecorder;
  let recordedChunks = [];
  let textOverlays = [];
  let imageOverlays = [];
  // State and Stacks
  let undoStack = [];
  let redoStack = [];
  let overlays = [];
  let audioURL = null;
  let editedVideoBlob = null;
  let videoURL = null;
  let currentAction = null;
  let startTime = 0; // in seconds
  let stopTime = 5; // in seconds
  // Timeline div elements
  const startDiv = document.getElementById('startDiv');
  const stopDiv = document.getElementById('stopDiv');
  let videoStream = null;
  let offsetX, offsetY; // Offset for drag positioning
  videoInput.addEventListener("change", (e) => {
    const file = e.target.files[0];
    if (file) {
      const url = URL.createObjectURL(file);
      videoPlayer.src = url;
      videoPlayer.load(); // Ensures the video metadata is loaded properly
      videoCanvas.width = videoPlayer.videoWidth || 640;
      videoCanvas.height = videoPlayer.videoHeight || 360;
      downloadButton.disabled = false;
    }
  });

  function renderVideoFrame() {
    ctx.clearRect(0, 0, videoCanvas.width, videoCanvas.height);
    ctx.drawImage(videoPlayer, 0, 0, videoCanvas.width, videoCanvas.height);
    // Render text overlays
    textOverlays.forEach(({
      text,
      x,
      y,
      color,
      fontSize,
      fontFamily
    }) => {
      ctx.fillStyle = color;
      ctx.font = `${fontSize}px ${fontFamily}`;
      ctx.fillText(text, x, y);
    });
    // Render image overlays
    imageOverlays.forEach(({
      image,
      x,
      y,
      width,
      height
    }) => {
      ctx.drawImage(image, x, y, width, height);
    });
    if (videoPlayer.paused || videoPlayer.ended) return; // Stop if video is paused or ended
    requestAnimationFrame(renderVideoFrame);
  }
  downloadButton.addEventListener("click", () => {
    recordedChunks = [];
    mediaRecorder = new MediaRecorder(videoCanvas.captureStream());
    mediaRecorder.ondataavailable = (e) => recordedChunks.push(e.data);
    mediaRecorder.onstop = () => {
      const blob = new Blob(recordedChunks, {
        type: "video/webm"
      });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = `edited-video-${new Date().toISOString()}.webm`;
      a.click();
    };
    mediaRecorder.start();
    videoPlayer.play();
    setTimeout(() => {
      mediaRecorder.stop();
    }, videoPlayer.duration * 1000);
  });
  videoPlayer.addEventListener("play", () => renderVideoFrame());
  // Load Video
  // Add Text Overlay
  document.getElementById("textOverlayButton").addEventListener("click", () => {
    showModal("textOverlayModal");
  });

  function addOverlay(type) {
    if (type === "text") {
      const text = document.getElementById("overlayTextInput").value;
      const color = document.getElementById("textColorInput").value;
      const fontSize = document.getElementById("fontSizeInput").value + "px";
      const fontFamily = document.getElementById("fontTypeInput").value;
      const overlay = document.createElement("div");
      overlay.textContent = text;
      overlay.style.cssText = `
overlay.style.position = "absolute";
overlay.style.color = color;
overlay.style.fontSize = fontSize;
overlay.style.fontFamily = fontFamily;
overlay.style.top = "10%";
overlay.style.left = "10%";

    `;
      makeDraggable(overlay);
      videoContainer.appendChild(overlay);
      overlays.push(overlay);
      saveActionState("addOverlay", {
        element: overlay
      });
      hideModal("textOverlayModal");
    }
  }

  function previewOverlay(type) {
    const previewContainer = document.getElementById("previewOverlayContainer");
    previewContainer.innerHTML = ''; // Clear previous preview
    if (type === "text") {
      const text = document.getElementById("overlayTextInput").value;
      const color = document.getElementById("textColorInput").value;
      const fontSize = document.getElementById("fontSizeInput").value + "px";
      const fontFamily = document.getElementById("fontTypeInput").value;
      const preview = document.createElement("div");
      preview.textContent = text;
      preview.style.cssText = `
      position: absolute;
      color: ${color};
      font-size: ${fontSize};
      font-family: ${fontFamily};
      top: 10%;
      left: 10%;
    `;
      previewContainer.appendChild(preview);
    }
  }
  // Add event listeners for live preview
  document.querySelectorAll("#overlayTextInput, #textColorInput, #fontSizeInput, #fontTypeInput")
    .forEach((el) => {
      el.addEventListener("input", () => previewOverlay("text"));
    });
  // Add event listener
  document.getElementById("saveTextOverlay").addEventListener("click", () => addOverlay("text"));
  // Add Image Overlay
  document.getElementById("imageButton").addEventListener("click", () => {
    showModal("imageModal");
  });
  // Add Text Overlay
  // Show and hide edit modal
  const editModal = document.getElementById('editOverlayModal');
  const saveEditButton = document.getElementById('saveEdit');
  const closeEditButton = document.getElementById('closeEditModal');
  // Track the active overlay
  let activeOverlay = null;
  // Add Text Overlay
  document.getElementById("saveTextOverlay").addEventListener("click", () => {
    const text = document.getElementById("overlayTextInput").value;
    const color = document.getElementById("textColorInput").value;
    const fontSize = document.getElementById("fontSizeInput").value;
    const overlay = document.createElement("div");
    overlay.textContent = text;
    overlay.style.position = "absolute";
    overlay.style.color = color;
    overlay.style.fontSize = `${fontSize}px`;
    overlay.style.top = "10%";
    overlay.style.left = "10%";
    // Add a unique ID and dataset for easy identification
    overlay.id = `overlay-${Date.now()}`; // Unique ID based on current timestamp
    overlay.dataset.type = 'text';
    overlay.dataset.content = text;
    makeDraggable(overlay);
    videoContainer.appendChild(overlay);
    overlays.push(overlay);
    saveActionState("addOverlay", {
      element: overlay
    });
  });
  // Add Image Overlay
  document.getElementById("saveImageOverlay").addEventListener("click", () => {
    const imageURL = document.getElementById("imageURLInput").value;
    const img = document.createElement("img");
    img.src = imageURL;
    img.style.position = "absolute";
    img.style.width = "100px";
    img.style.top = "10%";
    img.style.left = "10%";
    // Add a unique ID and dataset for easy identification
    img.id = `overlay-${Date.now()}`; // Unique ID based on current timestamp
    img.dataset.type = 'image';
    img.dataset.src = imageURL;
    makeDraggable(img);
    videoContainer.appendChild(img);
    overlays.push(img);
    saveToUndo("addOverlay", img);
    hideModal("imageModal");
  });
  // Handle editing of overlays
  function makeDraggable(overlay) {
    overlay.classList.add("draggable");
    overlay.setAttribute("draggable", true);
    overlay.addEventListener("dragstart", (e) => {
      draggedOverlay = overlay;
      setTimeout(() => {
        overlay.style.opacity = "0.5"; // Fade the overlay when dragging starts
      }, 0);
      const offsetX = e.clientX - overlay.getBoundingClientRect().left;
      const offsetY = e.clientY - overlay.getBoundingClientRect().top;
      overlay.dataset.offsetX = offsetX;
      overlay.dataset.offsetY = offsetY;
    });
    overlay.addEventListener("dragend", () => {
      setTimeout(() => {
        draggedOverlay.style.opacity = "1";
        draggedOverlay = null;
      }, 0);
    });
    overlay.addEventListener("drag", (e) => {
      if (draggedOverlay) {
        const offsetX = parseFloat(draggedOverlay.dataset.offsetX);
        const offsetY = parseFloat(draggedOverlay.dataset.offsetY);
        const x = e.clientX - videoContainer.offsetLeft - offsetX;
        const y = e.clientY - videoContainer.offsetTop - offsetY;
        draggedOverlay.style.left = `${x}px`;
        draggedOverlay.style.top = `${y}px`;
        if (y + draggedOverlay.offsetHeight > videoContainer.offsetHeight - 50) {
          trashIcon.classList.remove("hidden");
        } else {
          trashIcon.classList.add("hidden");
        }
      }
    });
    overlay.addEventListener("dragover", (e) => {
      e.preventDefault(); // Enable drop
    });
    overlay.addEventListener("drop", (e) => {
      if (draggedOverlay) {
        const overlayRect = draggedOverlay.getBoundingClientRect();
        const trashRect = trashIcon.getBoundingClientRect();
        if (overlayRect.bottom >= trashRect.top && overlayRect.top <= trashRect.bottom) {
          videoContainer.removeChild(draggedOverlay); // Remove the overlay
        }
        trashIcon.classList.add("hidden");
      }
    });
    // Add click listener to mark the overlay as active and open the edit modal
    overlay.addEventListener("click", (e) => {
      e.stopPropagation(); // Prevent the parent click event from triggering
      // Set overlay as active
      if (activeOverlay) {
        activeOverlay.classList.remove('active'); // Remove previous active state
      }
      overlay.classList.add('active');
      activeOverlay = overlay;
      // Open the edit modal
      openEditModal(overlay);
    });
  }
  // Open the Edit Modal and populate it with current overlay data
  // Open the edit modal with real-time updates
  function openEditModal(overlay) {
    if (overlay.dataset.type === "text") {
      document.getElementById("editTextInput").value = overlay.dataset.content;
      document.getElementById("editColorInput").value = overlay.style.color;
      document.getElementById("editFontSizeInput").value = parseInt(overlay.style.fontSize);
    }
    editModal.classList.add('show'); // Show the modal with animation
    // Set focus to the first input field when modal is opened
    document.getElementById("editTextInput").focus();
  }
  // Save the edited overlay with real-time feedback
  saveEditButton.addEventListener("click", () => {
    if (activeOverlay) {
      const text = document.getElementById("editTextInput").value;
      const color = document.getElementById("editColorInput").value;
      const fontSize = document.getElementById("editFontSizeInput").value;
      if (activeOverlay.dataset.type === "text") {
        activeOverlay.textContent = text;
        activeOverlay.style.color = color;
        activeOverlay.style.fontSize = `${fontSize}px`;
        activeOverlay.dataset.content = text;
      }
      editModal.classList.remove('show'); // Hide modal with animation
    }
  });
  // Close edit modal without saving
  closeEditButton.addEventListener("click", () => {
    editModal.style.display = "none"; // Hide modal
    if (activeOverlay) {
      activeOverlay.classList.remove('active'); // Remove active state
    }
  });
  // Close the modal if clicked outside of it
  window.addEventListener('click', (e) => {
    if (e.target === editModal) {
      editModal.style.display = "none";
      if (activeOverlay) {
        activeOverlay.classList.remove('active');
      }
    }
  });
  // Undo/Redo Functionality
  function saveToUndo(action, data) {
    undoStack.push({
      action,
      data
    });
    redoStack = []; // Clear redo stack on new action
    // Limit the undo stack size to 50 actions
    if (undoStack.length > 50) {
      undoStack.shift(); // Remove the oldest action to maintain a fixed size
    }
  }

  function showBeforeAfter(prevSrc, newSrc) {
    const beforeVideo = document.getElementById("beforeVideo");
    const afterVideo = document.getElementById("afterVideo");
    beforeVideo.src = prevSrc;
    afterVideo.src = newSrc;
  }
  // Update Undo/Redo to call comparison
  function saveActionState(actionType, actionData) {
    const state = {
      action: actionType,
      data: actionData
    };
    undoStack.push(state);
    redoStack = []; // Clear redo stack on new action
    toggleUndoRedo(); // Update button states
    // Update before/after view if needed
    if (actionData.prevVideoSrc && actionData.newVideoSrc) {
      showBeforeAfter(actionData.prevVideoSrc, actionData.newVideoSrc);
    }
  }
  // Helper Function: Toggle Undo/Redo Buttons
  function toggleUndoRedo() {
    undoButton.disabled = undoStack.length === 0;
    redoButton.disabled = redoStack.length === 0;
    undoButton.title = undoStack.length ? "Undo Last Action" : "Nothing to Undo";
    redoButton.title = redoStack.length ? "Redo Last Action" : "Nothing to Redo";
  }
  // Function: Undo Action
  function undoAction() {
    if (undoStack.length > 0) {
      const {
        action,
        data
      } = undoStack.pop();
      switch (action) {
        case "addOverlay":
          data.element.remove();
          overlays = overlays.filter((el) => el !== data.element);
          break;
        case "moveOverlay":
          data.element.style.left = data.prevX;
          data.element.style.top = data.prevY;
          break;
        case "addAudio":
          videoPlayer.src = data.prevVideoSrc; // Revert to previous video
          break;
        case "sliceVideo":
        case "appendMedia":
          videoPlayer.src = data.prevVideoSrc; // Revert video modification
          break;
      }
      redoStack.push({
        action,
        data
      });
      toggleUndoRedo();
    }
  }
  // Function: Redo Action
  function redoAction() {
    if (redoStack.length > 0) {
      const {
        action,
        data
      } = redoStack.pop();
      switch (action) {
        case "addOverlay":
          videoContainer.appendChild(data.element);
          overlays.push(data.element);
          break;
        case "moveOverlay":
          data.element.style.left = data.newX;
          data.element.style.top = data.newY;
          break;
        case "addAudio":
          mergeAudioWithVideo(data.audioSrc);
          break;
        case "sliceVideo":
        case "appendMedia":
          videoPlayer.src = data.newVideoSrc; // Re-apply video modification
          break;
      }
      undoStack.push({
        action,
        data
      });
      toggleUndoRedo();
    }
  }
  // Event Listeners
  undoButton.addEventListener("click", undoAction);
  redoButton.addEventListener("click", redoAction);
  // Modal Helpers
  function showModal(modalId) {
    const modal = document.getElementById(modalId);
    modal.classList.add("show");
    modal.setAttribute("aria-hidden", "false");
    modal.querySelector("input, button").focus(); // Focus first input/button for accessibility
  }

  function hideModal(modalId) {
    const modal = document.getElementById(modalId);
    modal.classList.remove("show");
    modal.setAttribute("aria-hidden", "true");
  }
</script>

<script>
  // Add Audio to Video
  // Add Audio to Video
  addAudioButton.addEventListener("click", () => {
    audioInput.click();
  });
  audioInput.addEventListener("change", (e) => {
    const audioFile = e.target.files[0];
    if (audioFile) {
      const audioURL = URL.createObjectURL(audioFile);
      const audioPreview = new Audio(audioURL);
      // Display audio preview controls
      const audioPreviewContainer = document.getElementById("audioPreviewContainer");
      audioPreviewContainer.innerHTML = `<audio controls><source src="${audioURL}" type="audio/mp3"></audio>`;
      // Optional: Automatically merge audio with video if the user confirms.
      audioPreview.oncanplaythrough = () => {
        mergeAudioWithVideo(audioURL);
        saveActionState("addAudio", {
          audioSrc: audioURL
        });
      };
    }
  });
  async function mergeAudioWithVideo(audioSrc) {
    const audio = new Audio(audioSrc);
    const stream = videoPlayer.captureStream();
    const audioStream = audio.captureStream();
    await audio.play(); // Ensure audio starts playing before recording
    const combinedStream = new MediaStream([...stream.getTracks(), ...audioStream.getAudioTracks()]);
    const mediaRecorder = new MediaRecorder(combinedStream);
    const chunks = [];
    return new Promise((resolve) => {
      mediaRecorder.ondataavailable = (e) => chunks.push(e.data);
      mediaRecorder.onstop = () => {
        const blob = new Blob(chunks, {
          type: "video/webm"
        });
        const mergedURL = URL.createObjectURL(blob);
        videoPlayer.src = mergedURL;
        resolve(mergedURL);
      };
      mediaRecorder.start();
      setTimeout(() => mediaRecorder.stop(), videoPlayer.duration * 1000);
    });
  }

  function sliceVideo(startTime, endTime) {
    videoPlayer.currentTime = startTime;
    const stream = videoPlayer.captureStream();
    const mediaRecorder = new MediaRecorder(stream);
    const chunks = [];
    mediaRecorder.ondataavailable = (e) => chunks.push(e.data);
    mediaRecorder.onstop = () => {
      const blob = new Blob(chunks, {
        type: "video/webm"
      });
      const slicedURL = URL.createObjectURL(blob);
      videoPlayer.src = slicedURL;
      videoPlayer.play();
    };
    mediaRecorder.start();
    setTimeout(() => {
      mediaRecorder.stop();
    }, (endTime - startTime) * 1000);
  }
  // Append Video or Image
  appendButton.addEventListener("click", () => {
    const fileInput = document.createElement("input");
    fileInput.type = "file";
    fileInput.accept = "video/*,image/*";
    fileInput.onchange = (e) => {
      const file = e.target.files[0];
      if (file) {
        appendMedia(URL.createObjectURL(file), file.type.startsWith("video"));
        saveActionState("appendMedia");
      }
    };
    fileInput.click();
  });

  function appendMedia(mediaSrc, isVideo) {
    const media = document.createElement(isVideo ? "video" : "img");
    media.src = mediaSrc;
    media.style.width = "100%";
    media.style.marginTop = "10px";
    document.getElementById("videoContainer").appendChild(media);
  }
  // Event listener for start time
  startDiv.addEventListener("mousedown", (e) => {
    const timeline = document.getElementById('timelineDiv');
    const timelineWidth = timeline.offsetWidth;
    const startDivWidth = startDiv.offsetWidth;
    // Calculate the offset of the center of the div
    const offsetX = e.clientX - startDiv.offsetLeft - startDivWidth / 2;
    // Position the startDiv by its center initially
    startDiv.style.position = 'absolute';
    const onMouseMove = (e) => {
      // Calculate the new left position of the startDiv, ensuring it moves within the bounds of the timeline
      let newLeft = e.clientX - offsetX;
      newLeft = Math.max(0, Math.min(newLeft, timelineWidth - startDivWidth));
      // Update startTime based on mouse position
      startTime = Math.min((newLeft / timelineWidth) * videoPlayer.duration, stopTime);
      updateStartDiv();
      updateSyncedTime(startDiv, startTime); // Update synced time on the start div
    };
    const onMouseUp = () => {
      document.removeEventListener("mousemove", onMouseMove);
      document.removeEventListener("mouseup", onMouseUp);
    };
    document.addEventListener("mousemove", onMouseMove);
    document.addEventListener("mouseup", onMouseUp);
  });
  // Event listener for stop time
  stopDiv.addEventListener("mousedown", (e) => {
    const timeline = document.getElementById('timelineDiv');
    const timelineWidth = timeline.offsetWidth;
    const stopDivWidth = stopDiv.offsetWidth;
    // Calculate the offset of the center of the div
    const offsetX = e.clientX - stopDiv.offsetLeft - stopDivWidth / 2;
    // Position the stopDiv by its center initially
    stopDiv.style.position = 'absolute';
    const onMouseMove = (e) => {
      // Calculate the new left position of the stopDiv, ensuring it moves within the bounds of the timeline
      let newLeft = e.clientX - offsetX;
      newLeft = Math.max(0, Math.min(newLeft, timelineWidth - stopDivWidth));
      // Update stopTime based on mouse position
      stopTime = Math.max((newLeft / timelineWidth) * videoPlayer.duration, startTime + 1);
      updateStopDiv();
      updateSyncedTime(stopDiv, stopTime); // Update synced time on the stop div
    };
    const onMouseUp = () => {
      document.removeEventListener("mousemove", onMouseMove);
      document.removeEventListener("mouseup", onMouseUp);
    };
    document.addEventListener("mousemove", onMouseMove);
    document.addEventListener("mouseup", onMouseUp);
  });
  // Update the timeline divs for start and stop times
  function updateStartDiv() {
    const timelineWidth = document.getElementById('timelineDiv').offsetWidth;
    startDiv.style.left = `${(startTime / videoPlayer.duration) * timelineWidth}px`;
    startDiv.innerText = startTime;
  }

  function updateStopDiv() {
    const timelineWidth = document.getElementById('timelineDiv').offsetWidth;
    stopDiv.style.left = `${(stopTime / videoPlayer.duration) * timelineWidth}px`;
    stopDiv.innerText = stopTime;
  }
  // Function to update synced time at the center of the div
  function updateSyncedTime(div, time) {
    const syncedTimeDisplay = div.querySelector('.syncedTime');
    if (syncedTimeDisplay) {
      syncedTimeDisplay.textContent = formatTime(time); // Display formatted time at the center
    }
  }
  // Helper function to format time (in seconds)
  function formatTime(timeInSeconds) {
    const minutes = Math.floor(timeInSeconds / 60);
    const seconds = Math.floor(timeInSeconds % 60);
    return `${minutes}:${seconds < 10 ? '0' + seconds : seconds}`;
  }
  // Function to slice the video and create a blob
  function sliceVideo() {
    const videoFile = videoPlayer.src; // Your video URL
    const mediaSource = new MediaSource();
    // Attach the MediaSource to the video player
    videoPlayer.src = URL.createObjectURL(mediaSource);
    mediaSource.addEventListener('sourceopen', function() {
      const sourceBuffer = mediaSource.addSourceBuffer('video/webm; codecs="vp8"');
      // Fetch the video data as an ArrayBuffer (for slicing purposes)
      fetch(videoFile)
        .then(response => response.arrayBuffer())
        .then(buffer => {
          const videoData = new Uint8Array(buffer);
          // Calculate start and stop byte positions based on video duration
          const startByte = Math.floor((startTime / videoPlayer.duration) * videoData.length);
          const stopByte = Math.floor((stopTime / videoPlayer.duration) * videoData.length);
          // Slice the video data between startByte and stopByte
          const slicedData = videoData.slice(startByte, stopByte);
          // Append the sliced data to the source buffer
          sourceBuffer.appendBuffer(slicedData);
          // Once the buffer is appended, signal the video to play the sliced segment
          sourceBuffer.addEventListener('updateend', () => {
            mediaSource.endOfStream(); // End the stream
            videoPlayer.play(); // Start playing the sliced video
          });
        })
        .catch(error => {
          console.error('Error fetching video data:', error);
        });
    });
  }

  function previewVideoSegment() {
    const video = videoPlayer;
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    // Set canvas size to match the video resolution
    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;
    // Seek to the start time of the segment
    video.currentTime = startTime;
    video.addEventListener('seeked', function() {
      // Capture the frame when the video reaches the start time
      ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
      // Optionally display this frame in an image element
      const image = new Image();
      image.src = canvas.toDataURL(); // Convert the canvas content to an image URL
      document.body.appendChild(image); // Show the captured frame on the page
      // Continue playing video and update canvas to show frames
      video.play();
    });
  }
  // Function to capture a frame from the video and render it on the canvas
  function renderVideoFrame() {
    ctx.clearRect(0, 0, videoCanvas.width, videoCanvas.height);
    ctx.drawImage(videoPlayer, 0, 0, videoCanvas.width, videoCanvas.height);
    if (videoPlayer.paused || videoPlayer.ended) return; // Stop if video is paused or ended
    requestAnimationFrame(renderVideoFrame);
  }
  // Add Event Listener to the slice button to trigger video slicing
  document.getElementById("sliceVideoButton").addEventListener("click", sliceVideo);
  document.getElementById("previewVideoSegment").addEventListener("click", previewVideoSegment);
  // Render the frame when video is playing
  videoPlayer.addEventListener("play", () => {
    renderVideoFrame();
  });
  // Update start and stop times with the timeline on play
  videoPlayer.addEventListener("timeupdate", () => {
    if (videoPlayer.currentTime >= startTime && videoPlayer.currentTime <= stopTime) {
      // Sync video current time with the timeline divs
      updateStartDiv();
      updateStopDiv();
    }
  });
  toggleUndoRedo();







    // When the button is clicked, trigger the file input
    uploadButton.addEventListener("click", () => {
      videoInput.click();
    });

    // Log the selected file (optional: for debugging)
    videoInput.addEventListener("change", (event) => {
      const file = event.target.files[0];
      if (file) {
        console.log("Selected video file:", file.name);
      }
    });
</script>























    <!-- Footer -->
    <footer id="dynamic-footer"></footer>
    
    <!-- Firebase configuration/ Login& Out -->
    <script type="module" src="https://reelcareer.co/public/js/main.js"></script> 

   
    

    <!-- Firebase JS SDK and Custom Scripts -->

    <script type="module">
        import {
            db, doc, getDoc, query, updateDoc,
            setDoc, ref, signInWithPopup, orderBy, limit,startAfter ,
             
            uploadBytes, OAuthProvider, arrayUnion, getStorage,
            signOut, addDoc, increment, onAuthStateChanged,
            createUserWithEmailAndPassword, signInWithEmailAndPassword,
            where, getDocs, storage, collection, deleteObject, 
            auth, analytics, deleteDoc, getDownloadURL
        } from 'https://reelcareer.co/js/module.js';


/*


        function getQueryParam(param) {
        const urlParams = new URLSearchParams(window.location.search);
        return urlParams.get(param);
    }  
    

   

function setBlogMetaTags(blogData) {
    // Update the document title
    document.title = `ReelCareer.co | Blog: ${blogData.title}`;

    // Helper function to create or update a meta tag
    function updateMetaTag(name, content, property = false) {
        let meta = document.querySelector(property ? `meta[property="${name}"]` : `meta[name="${name}"]`);
        if (!meta) {
            meta = document.createElement('meta');
            if (property) {
                meta.setAttribute('property', name);
            } else {
                meta.setAttribute('name', name);
            }
            document.head.appendChild(meta);
        }
        meta.setAttribute('content', content);
    }

    // Meta tags for SEO
    updateMetaTag('description', blogData.description || 'Read this insightful blog on ReelCareer.co!');
    updateMetaTag('keywords', blogData.keywords || 'ReelCareer, blog, career, jobs');
    updateMetaTag('author', blogData.author || 'ReelCareer Team');

    // Open Graph (OG) meta tags for social media sharing
    updateMetaTag('og:title', `ReelCareer.co | Blog: ${blogData.title}`, true);
    updateMetaTag('og:description', blogData.description || 'Discover this blog post on ReelCareer.co!', true);
    updateMetaTag('og:image', blogData.image || 'https://reelcareer.co/images/default-blog-thumbnail.png', true);
    updateMetaTag('og:url', blogData.url || window.location.href, true);
    updateMetaTag('og:type', 'article', true);

    // Twitter card meta tags
    updateMetaTag('twitter:card', 'summary_large_image');
    updateMetaTag('twitter:title', `ReelCareer.co | Blog: ${blogData.title}`);
    updateMetaTag('twitter:description', blogData.description || 'Check out this blog post on ReelCareer!');
    updateMetaTag('twitter:image', blogData.image || 'https://reelcareer.co/images/default-blog-thumbnail.png');
}







// Initial call to fetch total posts and blogs for the first page
window.onload = async function () {
    try {

    } catch (error) {
        console.error("Error during initialization:", error);
    }
};

*/

    </script>


    
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>
