<!DOCTYPE html>
<html lang="en">
  <head>
    <!-- Basic Meta Tags -->
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Discover job seekers' video resumes on ReelCareer. Browse video reels, connect with candidates, and hire talent with ease.">
    <meta name="keywords" content="video resumes, job seekers, career videos, hire talent, video profiles, professional videos, job board, employment videos, ReelCareer">
    <meta name="author" content="ReelCareer">
    <meta name="robots" content="index, follow">
    <meta name="language" content="en-US">
    <meta name="geo.region" content="US-TX">
    <meta name="geo.placename" content="Dallas, Texas">

    <!-- Title -->
    <title>Explore Video Resumes | ReelCareer Job Board</title>

    <!-- Open Graph Meta Tags -->
    <meta property="og:title" content="Explore Job Seekers' Video Resumes | ReelCareer">
    <meta property="og:description" content="Watch professional video resumes and connect with top candidates on ReelCareer's job board. Simplify your hiring process.">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://www.reelcareer.co/reels">
    <meta property="og:image" content="https://www.reelcareer.co/images/sq_logo_n_BG_tie_reelx.png">
    <meta property="og:site_name" content="ReelCareer">
    <meta property="og:locale" content="en_US">

    <!-- Twitter Card Meta Tags -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@ReelCareer">
    <meta name="twitter:title" content="Discover Video Resumes | ReelCareer">
    <meta name="twitter:description" content="Browse professional video resumes, connect with candidates, and streamline your hiring process with ReelCareer.">
    <meta name="twitter:image" content="https://www.reelcareer.co/images/sq_logo_n_BG_tie_reelx.png">

  <!-- Canonical Tag for SEO -->
  <link rel="canonical" href="https://www.reelcareer.co/reels">

  <!-- Standard Favicon -->
  <link rel="icon" type="image/x-icon" href="https://www.ReelCareer.co/images/favicons/favicon.ico">

  <!-- 32x32 Favicon -->
  <link rel="icon" type="image/png" sizes="32x32" href="https://www.ReelCareer.co/images/favicons/favicon-32x32.png">

  <!-- 16x16 Favicon -->
  <link rel="icon" type="image/png" sizes="16x16" href="https://www.ReelCareer.co/images/favicons/favicon-16x16.png">

  <!-- Apple Touch Icon -->
  <link rel="apple-touch-icon" sizes="180x180" href="https://www.ReelCareer.co/images/favicons/apple-touch-icon.png">

  <!-- Android Favicon (192x192) -->
  <link rel="icon" type="image/png" sizes="192x192" href="https://www.ReelCareer.co/images/favicons/android-chrome-192x192.png">

  <!-- Chrome Favicon (512x512) -->
  <link rel="icon" type="image/png" sizes="512x512" href="https://www.ReelCareer.co/images/favicons/android-chrome-512x512.png">

   <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">
<!--
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
-->
  
   <!-- Bootstrap CSS -->
   <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">
    
    <script src="https://reelcareer.co/public/js/scripts.js"></script>
    <script src="https://reelcareer.co/public/js/loadScripts.js"></script>
   
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&family=Montserrat:wght@400;500;700&display=swap" rel="stylesheet">

    <link
    rel="stylesheet"
    href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css"
  />
    <link rel="stylesheet" href="https://reelcareer.co/public/css/styles.css">
   
   
   
</head>


<body>
    <script src="https://reelcareer.co/public/js/bodyload.js"></script>
    <nav></nav>


    <nav aria-label="breadcrumb">
      <ol class="breadcrumb">
          <li id="lastBreadcrumb_profile" class="breadcrumb-item"><a href="https://reelcareer.co/views/user">Profile</a></li>
          <li id="lastBreadcrumb_messages" class="breadcrumb-item"><a href="https://reelcareer.co/views/messaging">Messages</a></li>
          <li id="lastBreadcrumb_last" class="breadcrumb-item"><a id="lastBreadcrumb_a" href="https://reelcareer.co/views/create">Create Reel</a></li>
          <li id="breadcrumb-active-title" class="breadcrumb-item active" aria-current="page">User</li>
        </ol>
    </nav>

        <style>
          /* General Styles */
          body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;

          }
          .video-reel-container {
    width: 100%;
    max-width: 640px;
    margin: 0 auto;
    background-color: #000;
    color: #fff;
    box-sizing: border-box;
padding: 10px;
    border-radius: 10px;
}

.video-player-container {
    width: 100%;
    height: 360px;
    margin-bottom: 10px;
    background-color: #333;
    border-radius: 10px;
}

.video-player {
    width: 100%;
    height: 100%;
    border-radius: 10px;
}

.controls-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    margin-top: 10px;
}

.actions {
    display: flex;
    justify-content: space-around;
    width: 100%;
    margin-bottom: 10px;
}

.action-btn {
    background: transparent;
    border: none;
    color: white;
    font-size: 24px;
    cursor: pointer;
}

.action-btn:hover {
    color: #1d72b8;
}

.video-details {
    display: flex;
    justify-content: space-between;
    width: 100%;
    margin-bottom: 10px;
}

.video-details p {
    margin: 0;
    font-size: 14px;
}

.video-upload-section {
    display: flex;
    justify-content: center;
    width: 100%;
    margin-top: 10px;
}

#uploadButton {
    background-color: #1d72b8;
    color: white;
    border: none;
    padding: 10px;
    font-size: 16px;
    border-radius: 5px;
    cursor: pointer;
}

#uploadButton:hover {
    background-color: #155a8a;
}
#videoContainer {
      position: relative;
      width: 640px;
      height: 360px;
      margin: 20px auto;
      border: 1px solid #ccc;
    }
    video {
      width: 100%;
      height: 100%;
    }
    canvas {
      display: none;
    }
    .draggable {
      cursor: grab;
    }
    .hidden {
      display: none;
    }
        </style>
  <!-- Modal styles -->
<style>
  .modal {
    display: none;
    position: fixed;
    z-index: 1;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    overflow: auto;
    background-color: rgba(0, 0, 0, 0.4);
  }
  .modal-content {
    background-color: #fefefe;
    margin: 15% auto;
    padding: 20px;
    border: 1px solid #888;
    width: 80%;
    max-width: 400px;
  }

  main #videoContainer {
  width: 100%;
  display: block;


}

main #videoPlayer {
  width: 100%;
  display: block;


}


  button:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }


main #timelineContainer {
  width: 100%;
  display: block;


}
main #overlayControls {
    width: 100%;
    display: block;
}

/* CSS for showing and hiding modals */
.modal {
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.7);
  z-index: 9999;
  align-items: center;
  justify-content: center;
}

.modal.show {
  display: flex;
}






  .modal-content {
    background-color: #fff;
    padding: 20px;
    margin: 15% auto;
    width: 80%; max-width: 400px;
    text-align: center;
  }
</style>


<main id="main-content">
  <!-- Video Container -->
  <div id="videoContainer">
    <video id="videoPlayer" controls autoplay></video>
    <canvas id="videoCanvas" style="display: none;"></canvas>
  </div>

  <!-- Audio Input -->

  <input type="file" id="videoInput" accept="video/*" title="Select a video to upload" />
  <input type="file" id="audioInput" accept="audio/*" class="hidden" title="Select an audio file to add" />
  <input type="file" id="videoSliceInput" accept="video/*" title="Select a video slice to append" />
  
  <!-- Add Trash Can Icon -->
<i id="trashIcon" class="hidden" style="position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); font-size: 40px; color: red;">üóëÔ∏è</i>


  <!-- Overlay Controls -->
  <div id="overlayControls">
      <!-- Video Slice & Append -->
    <button id="addAudioButton">Add Audio</button>
    <button id="sliceVideoButton">Slice Video</button>
    <button id="appendVideoButton">Append Video/Image</button>

    <button id="undoButton" aria-label="Undo last action" title="Undo">Undo</button>
    <button id="redoButton" aria-label="Redo last action" title="Redo">Redo</button>
    
    <button id="downloadButton" disabled>Render & Download</button>
    
    <!-- Add Image or Text Overlays -->
    <button id="textOverlayButton">Add Text Overlay</button>
    <button id="imageButton">Add Image Overlay</button>
  </div>

  <div id="beforeAfterContainer">
    <div>
      <h3>Before</h3>
      <video id="beforeVideo" controls></video>
    </div>
    <div>
      <h3>After</h3>
      <video id="afterVideo" controls></video>
    </div>
  </div>
  
</main>
<div id="sliceModal" style="display:none;">
  <label>Start Time (seconds):</label>
  <input type="number" id="startTimeInput" />
  <label>End Time (seconds):</label>
  <input type="number" id="endTimeInput" />
  <button id="confirmSlice">Slice Video</button>
</div>

<!-- Text Overlay Modal -->
<div id="textOverlayModal" class="modal">
  <div class="modal-content">
    <h3>Add Text Overlay</h3>
    <input type="text" id="overlayTextInput" placeholder="Enter text" required />
    <input type="color" id="textColorInput" value="#ffffff" />
    <input type="number" id="fontSizeInput" value="20" min="10" max="100" required />
    <select id="fontTypeInput">
      <option value="Arial">Arial</option>
      <option value="Verdana">Verdana</option>
      <option value="Tahoma">Tahoma</option>
    </select>
    <button id="saveTextOverlay">Save</button>
  </div>
</div>



<!-- Image Overlay Modal -->
<div id="imageModal" class="modal">
  <div class="modal-content">
    <h3>Add Image Overlay</h3>
    <input type="url" id="imageURLInput" placeholder="Enter image URL" />
    <button id="saveImageOverlay">Save</button>
  </div>
</div>

<!-- Edit Modal -->
<div id="editOverlayModal" class="modal">
  <div class="modal-content">
    <label for="editTextInput">Text:</label>
    <input type="text" id="editTextInput">
    <label for="editColorInput">Color:</label>
    <input type="color" id="editColorInput">
    <label for="editFontSizeInput">Font Size:</label>
    <input type="number" id="editFontSizeInput">
    <button id="saveEdit">Save Changes</button>
    <button id="closeEditModal">Cancel</button>
  </div>
</div>



<script>
// Core Elements
const videoPlayer = document.getElementById("videoPlayer");
const videoInput = document.getElementById("videoInput");
const downloadButton = document.getElementById("downloadButton");
const addAudioButton = document.getElementById("addAudioButton");
const audioInput = document.getElementById("audioInput");
const sliceButton = document.getElementById("sliceVideoButton");
const appendButton = document.getElementById("appendVideoButton");
const undoButton = document.getElementById("undoButton");
const redoButton = document.getElementById("redoButton");


const videoContainer = document.getElementById("videoContainer");

const videoCanvas = document.getElementById("videoCanvas");

  const canvas = document.getElementById("videoCanvas");
  const ctx = canvas.getContext("2d");

  let mediaRecorder;
  let recordedChunks = [];
  let textOverlays = [];
  let imageOverlays = [];
  
    // State and Stacks
    let undoStack = [];
let redoStack = [];
let overlays = [];
let audioURL = null;


let editedVideoBlob = null;
let videoURL = null;
    let currentAction = null;
 


    let videoStream = null;
let offsetX, offsetY; // Offset for drag positioning

  videoInput.addEventListener("change", (e) => {
    const file = e.target.files[0];
    if (file) {
      const url = URL.createObjectURL(file);
videoPlayer.src = url;
videoPlayer.load();  // Ensures the video metadata is loaded properly

      canvas.width = videoPlayer.videoWidth || 640;
      canvas.height = videoPlayer.videoHeight || 360;
      downloadButton.disabled = false;
    }
  });

  function renderVideoFrame() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.drawImage(videoPlayer, 0, 0, canvas.width, canvas.height);

    // Render text overlays
    textOverlays.forEach(({ text, x, y, color, fontSize, fontFamily }) => {
      ctx.fillStyle = color;
      ctx.font = `${fontSize}px ${fontFamily}`;
      ctx.fillText(text, x, y);
    });

    // Render image overlays
    imageOverlays.forEach(({ image, x, y, width, height }) => {
      ctx.drawImage(image, x, y, width, height);
    });

    if (videoPlayer.paused || videoPlayer.ended) return;  // Stop if video is paused or ended
requestAnimationFrame(renderVideoFrame);
  }



  downloadButton.addEventListener("click", () => {
    recordedChunks = [];
    mediaRecorder = new MediaRecorder(canvas.captureStream());
    mediaRecorder.ondataavailable = (e) => recordedChunks.push(e.data);
    mediaRecorder.onstop = () => {
  const blob = new Blob(recordedChunks, { type: "video/webm" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = `edited-video-${new Date().toISOString()}.webm`;
  a.click();
};
    mediaRecorder.start();
    videoPlayer.play();

    setTimeout(() => {
      mediaRecorder.stop();
    }, videoPlayer.duration * 1000);
  });

  videoPlayer.addEventListener("play", () => renderVideoFrame());


// Load Video




// Add Text Overlay
document.getElementById("textOverlayButton").addEventListener("click", () => {
  showModal("textOverlayModal");
});

function addOverlay(type) {
  if (type === "text") {
    const text = document.getElementById("overlayTextInput").value;
    const color = document.getElementById("textColorInput").value;
    const fontSize = document.getElementById("fontSizeInput").value + "px";
    const fontFamily = document.getElementById("fontTypeInput").value;

    const overlay = document.createElement("div");
    overlay.textContent = text;
    overlay.style.cssText = `
overlay.style.position = "absolute";
overlay.style.color = color;
overlay.style.fontSize = fontSize;
overlay.style.fontFamily = fontFamily;
overlay.style.top = "10%";
overlay.style.left = "10%";

    `;
    makeDraggable(overlay);
    videoContainer.appendChild(overlay);
    overlays.push(overlay);
    saveActionState("addOverlay", { element: overlay });
    hideModal("textOverlayModal");
  }
}
function previewOverlay(type) {
  const previewContainer = document.getElementById("previewOverlayContainer");
  previewContainer.innerHTML = ''; // Clear previous preview

  if (type === "text") {
    const text = document.getElementById("overlayTextInput").value;
    const color = document.getElementById("textColorInput").value;
    const fontSize = document.getElementById("fontSizeInput").value + "px";
    const fontFamily = document.getElementById("fontTypeInput").value;
    
    const preview = document.createElement("div");
    preview.textContent = text;
    preview.style.cssText = `
      position: absolute;
      color: ${color};
      font-size: ${fontSize};
      font-family: ${fontFamily};
      top: 10%;
      left: 10%;
    `;
    previewContainer.appendChild(preview);
  }
}

// Add event listeners for live preview
document.querySelectorAll("#overlayTextInput, #textColorInput, #fontSizeInput, #fontTypeInput")
  .forEach((el) => {
    el.addEventListener("input", () => previewOverlay("text"));
  });

// Add event listener
document.getElementById("saveTextOverlay").addEventListener("click", () => addOverlay("text"));


// Add Image Overlay
document.getElementById("imageButton").addEventListener("click", () => {
  showModal("imageModal");
});

// Add Text Overlay
// Show and hide edit modal
const editModal = document.getElementById('editOverlayModal');
const saveEditButton = document.getElementById('saveEdit');
const closeEditButton = document.getElementById('closeEditModal');

// Track the active overlay
let activeOverlay = null;

// Add Text Overlay
document.getElementById("saveTextOverlay").addEventListener("click", () => {
  const text = document.getElementById("overlayTextInput").value;
  const color = document.getElementById("textColorInput").value;
  const fontSize = document.getElementById("fontSizeInput").value;

  const overlay = document.createElement("div");
  overlay.textContent = text;
  overlay.style.position = "absolute";
  overlay.style.color = color;
  overlay.style.fontSize = `${fontSize}px`;
  overlay.style.top = "10%";
  overlay.style.left = "10%";

  // Add a unique ID and dataset for easy identification
  overlay.id = `overlay-${Date.now()}`; // Unique ID based on current timestamp
  overlay.dataset.type = 'text';
  overlay.dataset.content = text;

  makeDraggable(overlay);
  videoContainer.appendChild(overlay);
  overlays.push(overlay);
  saveActionState("addOverlay", { element: overlay });
});

// Add Image Overlay
document.getElementById("saveImageOverlay").addEventListener("click", () => {
  const imageURL = document.getElementById("imageURLInput").value;
  const img = document.createElement("img");
  img.src = imageURL;
  img.style.position = "absolute";
  img.style.width = "100px";
  img.style.top = "10%";
  img.style.left = "10%";

  // Add a unique ID and dataset for easy identification
  img.id = `overlay-${Date.now()}`; // Unique ID based on current timestamp
  img.dataset.type = 'image';
  img.dataset.src = imageURL;

  makeDraggable(img);

  videoContainer.appendChild(img);
  overlays.push(img);
  saveToUndo("addOverlay", img);
  hideModal("imageModal");
});

// Handle editing of overlays
function makeDraggable(overlay) {
  overlay.classList.add("draggable");
  overlay.setAttribute("draggable", true);

  overlay.addEventListener("dragstart", (e) => {
    draggedOverlay = overlay;
    setTimeout(() => {
      overlay.style.opacity = "0.5"; // Fade the overlay when dragging starts
    }, 0);

    const offsetX = e.clientX - overlay.getBoundingClientRect().left;
    const offsetY = e.clientY - overlay.getBoundingClientRect().top;
    overlay.dataset.offsetX = offsetX;
    overlay.dataset.offsetY = offsetY;
  });

  overlay.addEventListener("dragend", () => {
    setTimeout(() => {
      draggedOverlay.style.opacity = "1";
      draggedOverlay = null;
    }, 0);
  });

  overlay.addEventListener("drag", (e) => {
    if (draggedOverlay) {
      const offsetX = parseFloat(draggedOverlay.dataset.offsetX);
      const offsetY = parseFloat(draggedOverlay.dataset.offsetY);

      const x = e.clientX - videoContainer.offsetLeft - offsetX;
      const y = e.clientY - videoContainer.offsetTop - offsetY;

      draggedOverlay.style.left = `${x}px`;
      draggedOverlay.style.top = `${y}px`;

      if (y + draggedOverlay.offsetHeight > videoContainer.offsetHeight - 50) {
        trashIcon.classList.remove("hidden");
      } else {
        trashIcon.classList.add("hidden");
      }
    }
  });

  overlay.addEventListener("dragover", (e) => {
    e.preventDefault(); // Enable drop
  });

  overlay.addEventListener("drop", (e) => {
    if (draggedOverlay) {
      const overlayRect = draggedOverlay.getBoundingClientRect();
      const trashRect = trashIcon.getBoundingClientRect();

      if (overlayRect.bottom >= trashRect.top && overlayRect.top <= trashRect.bottom) {
        videoContainer.removeChild(draggedOverlay); // Remove the overlay
      }
      trashIcon.classList.add("hidden");
    }
  });

  // Add click listener to mark the overlay as active and open the edit modal
  overlay.addEventListener("click", (e) => {
    e.stopPropagation(); // Prevent the parent click event from triggering

    // Set overlay as active
    if (activeOverlay) {
      activeOverlay.classList.remove('active'); // Remove previous active state
    }
    overlay.classList.add('active');
    activeOverlay = overlay;

    // Open the edit modal
    openEditModal(overlay);
  });
}

// Open the Edit Modal and populate it with current overlay data
function openEditModal(overlay) {
  if (overlay.dataset.type === "text") {
    document.getElementById("editTextInput").value = overlay.dataset.content;
    document.getElementById("editColorInput").value = overlay.style.color;
    document.getElementById("editFontSizeInput").value = parseInt(overlay.style.fontSize);
  } else if (overlay.dataset.type === "image") {
    // Handle image overlay edits if necessary
  }

  editModal.style.display = "block"; // Show the modal
}

// Save edited overlay
saveEditButton.addEventListener("click", () => {
  if (activeOverlay) {
    const text = document.getElementById("editTextInput").value;
    const color = document.getElementById("editColorInput").value;
    const fontSize = document.getElementById("editFontSizeInput").value;

    if (activeOverlay.dataset.type === "text") {
      activeOverlay.textContent = text;
      activeOverlay.style.color = color;
      activeOverlay.style.fontSize = `${fontSize}px`;
      activeOverlay.dataset.content = text;
    }

    editModal.style.display = "none"; // Hide modal after saving
  }
});

// Close edit modal without saving
closeEditButton.addEventListener("click", () => {
  editModal.style.display = "none"; // Hide modal
  if (activeOverlay) {
    activeOverlay.classList.remove('active'); // Remove active state
  }
});

// Close the modal if clicked outside of it
window.addEventListener('click', (e) => {
  if (e.target === editModal) {
    editModal.style.display = "none";
    if (activeOverlay) {
      activeOverlay.classList.remove('active');
    }
  }
});


// Undo/Redo Functionality
function saveToUndo(action, data) {
  undoStack.push({ action, data });
  redoStack = [];  // Clear redo stack on new action

  // Limit the undo stack size to 50 actions
  if (undoStack.length > 50) {
    undoStack.shift();  // Remove the oldest action to maintain a fixed size
  }
}



function showBeforeAfter(prevSrc, newSrc) {
  const beforeVideo = document.getElementById("beforeVideo");
  const afterVideo = document.getElementById("afterVideo");

  beforeVideo.src = prevSrc;
  afterVideo.src = newSrc;
}

// Update Undo/Redo to call comparison
function saveActionState(actionType, actionData) {
  const state = { action: actionType, data: actionData };
  
  undoStack.push(state);
  redoStack = [];  // Clear redo stack on new action
  
  toggleUndoRedo();  // Update button states
  
  // Update before/after view if needed
  if (actionData.prevVideoSrc && actionData.newVideoSrc) {
    showBeforeAfter(actionData.prevVideoSrc, actionData.newVideoSrc);
  }
}

// Helper Function: Toggle Undo/Redo Buttons
function toggleUndoRedo() {
  undoButton.disabled = undoStack.length === 0;
  redoButton.disabled = redoStack.length === 0;

  undoButton.title = undoStack.length ? "Undo Last Action" : "Nothing to Undo";
  redoButton.title = redoStack.length ? "Redo Last Action" : "Nothing to Redo";
}



// Function: Undo Action
function undoAction() {
  if (undoStack.length > 0) {
    const { action, data } = undoStack.pop();

    switch (action) {
      case "addOverlay":
        data.element.remove();
        overlays = overlays.filter((el) => el !== data.element);
        break;

      case "moveOverlay":
        data.element.style.left = data.prevX;
        data.element.style.top = data.prevY;
        break;

      case "addAudio":
        videoPlayer.src = data.prevVideoSrc; // Revert to previous video
        break;

      case "sliceVideo":
      case "appendMedia":
        videoPlayer.src = data.prevVideoSrc; // Revert video modification
        break;
    }

    redoStack.push({ action, data });
    toggleUndoRedo();
  }
}

// Function: Redo Action
function redoAction() {
  if (redoStack.length > 0) {
    const { action, data } = redoStack.pop();

    switch (action) {
      case "addOverlay":
        videoContainer.appendChild(data.element);
        overlays.push(data.element);
        break;

      case "moveOverlay":
        data.element.style.left = data.newX;
        data.element.style.top = data.newY;
        break;

      case "addAudio":
        mergeAudioWithVideo(data.audioSrc);
        break;

      case "sliceVideo":
      case "appendMedia":
        videoPlayer.src = data.newVideoSrc; // Re-apply video modification
        break;
    }

    undoStack.push({ action, data });
    toggleUndoRedo();
  }
}

   // Event Listeners
undoButton.addEventListener("click", undoAction);
redoButton.addEventListener("click", redoAction); 




// Modal Helpers
function showModal(modalId) {
  const modal = document.getElementById(modalId);
  modal.classList.add("show");
  modal.setAttribute("aria-hidden", "false");
  modal.querySelector("input, button").focus();  // Focus first input/button for accessibility
}

function hideModal(modalId) {
  const modal = document.getElementById(modalId);
  modal.classList.remove("show");
  modal.setAttribute("aria-hidden", "true");
}


</script>






<script>

    // Add Audio to Video

// Add Audio to Video
addAudioButton.addEventListener("click", () => {
  audioInput.click();
});

audioInput.addEventListener("change", (e) => {
  const audioFile = e.target.files[0];
  if (audioFile) {
    const audioURL = URL.createObjectURL(audioFile);
    const audioPreview = new Audio(audioURL);
    
    // Display audio preview controls
    const audioPreviewContainer = document.getElementById("audioPreviewContainer");
    audioPreviewContainer.innerHTML = `<audio controls><source src="${audioURL}" type="audio/mp3"></audio>`;
    
    // Optional: Automatically merge audio with video if the user confirms.
    audioPreview.oncanplaythrough = () => {
      mergeAudioWithVideo(audioURL);
      saveActionState("addAudio", { audioSrc: audioURL });
    };
  }
});


async function mergeAudioWithVideo(audioSrc) {
  const audio = new Audio(audioSrc);
  const stream = videoPlayer.captureStream();
  const audioStream = audio.captureStream();

  await audio.play(); // Ensure audio starts playing before recording

  const combinedStream = new MediaStream([...stream.getTracks(), ...audioStream.getAudioTracks()]);
  const mediaRecorder = new MediaRecorder(combinedStream);
  const chunks = [];

  return new Promise((resolve) => {
    mediaRecorder.ondataavailable = (e) => chunks.push(e.data);
    mediaRecorder.onstop = () => {
      const blob = new Blob(chunks, { type: "video/webm" });
      const mergedURL = URL.createObjectURL(blob);
      videoPlayer.src = mergedURL;
      resolve(mergedURL);
    };

    mediaRecorder.start();
    setTimeout(() => mediaRecorder.stop(), videoPlayer.duration * 1000);
  });
}


// Slice Video
sliceButton.addEventListener("click", () => {
  const startTime = parseFloat(prompt("Enter start time (seconds):"));
  const endTime = parseFloat(prompt("Enter end time (seconds):"));

  if (startTime < endTime) {
    const prevVideoSrc = videoPlayer.src;
    const stream = videoPlayer.captureStream();
    const mediaRecorder = new MediaRecorder(stream);
    const chunks = [];

    videoPlayer.currentTime = startTime;
    mediaRecorder.ondataavailable = (e) => chunks.push(e.data);
    mediaRecorder.onstop = () => {
      const blob = new Blob(chunks, { type: "video/webm" });
      const slicedURL = URL.createObjectURL(blob);
      videoPlayer.src = slicedURL;
      saveActionState("sliceVideo", { prevVideoSrc, newVideoSrc: slicedURL });
    };

    mediaRecorder.start();
    setTimeout(() => mediaRecorder.stop(), (endTime - startTime) * 1000);
  }
});


    function sliceVideo(startTime, endTime) {
      videoPlayer.currentTime = startTime;

      const stream = videoPlayer.captureStream();
      const mediaRecorder = new MediaRecorder(stream);
      const chunks = [];

      mediaRecorder.ondataavailable = (e) => chunks.push(e.data);
      mediaRecorder.onstop = () => {
        const blob = new Blob(chunks, { type: "video/webm" });
        const slicedURL = URL.createObjectURL(blob);
        videoPlayer.src = slicedURL;
        videoPlayer.play();
      };

      mediaRecorder.start();
      setTimeout(() => {
        mediaRecorder.stop();
      }, (endTime - startTime) * 1000);
    }

    // Append Video or Image
    appendButton.addEventListener("click", () => {
      const fileInput = document.createElement("input");
      fileInput.type = "file";
      fileInput.accept = "video/*,image/*";
      fileInput.onchange = (e) => {
        const file = e.target.files[0];
        if (file) {
          appendMedia(URL.createObjectURL(file), file.type.startsWith("video"));
          saveActionState("appendMedia");
        }
      };
      fileInput.click();
    });

    function appendMedia(mediaSrc, isVideo) {
      const media = document.createElement(isVideo ? "video" : "img");
      media.src = mediaSrc;
      media.style.width = "100%";
      media.style.marginTop = "10px";
      document.getElementById("videoContainer").appendChild(media);
    }


    sliceButton.addEventListener("click", () => {
  document.getElementById("sliceModal").style.display = "block";
});

document.getElementById("confirmSlice").addEventListener("click", () => {
  const startTime = parseFloat(document.getElementById("startTimeInput").value);
  const endTime = parseFloat(document.getElementById("endTimeInput").value);
  if (startTime < endTime) {
    const prevVideoSrc = videoPlayer.src;
    sliceVideo(startTime, endTime, prevVideoSrc);
    document.getElementById("sliceModal").style.display = "none";
  }
});




    toggleUndoRedo();
</script>

























    <!-- Footer -->
    <footer id="dynamic-footer"></footer>
    
    <!-- Firebase configuration/ Login& Out -->
    <script type="module" src="https://reelcareer.co/public/js/main.js"></script> 

   
    

    <!-- Firebase JS SDK and Custom Scripts -->

    <script type="module">
        import {
            db, doc, getDoc, query, updateDoc,
            setDoc, ref, signInWithPopup, orderBy, limit,startAfter ,
             
            uploadBytes, OAuthProvider, arrayUnion, getStorage,
            signOut, addDoc, increment, onAuthStateChanged,
            createUserWithEmailAndPassword, signInWithEmailAndPassword,
            where, getDocs, storage, collection, deleteObject, 
            auth, analytics, deleteDoc, getDownloadURL
        } from 'https://reelcareer.co/js/module.js';


/*


        function getQueryParam(param) {
        const urlParams = new URLSearchParams(window.location.search);
        return urlParams.get(param);
    }  
    

   

function setBlogMetaTags(blogData) {
    // Update the document title
    document.title = `ReelCareer.co | Blog: ${blogData.title}`;

    // Helper function to create or update a meta tag
    function updateMetaTag(name, content, property = false) {
        let meta = document.querySelector(property ? `meta[property="${name}"]` : `meta[name="${name}"]`);
        if (!meta) {
            meta = document.createElement('meta');
            if (property) {
                meta.setAttribute('property', name);
            } else {
                meta.setAttribute('name', name);
            }
            document.head.appendChild(meta);
        }
        meta.setAttribute('content', content);
    }

    // Meta tags for SEO
    updateMetaTag('description', blogData.description || 'Read this insightful blog on ReelCareer.co!');
    updateMetaTag('keywords', blogData.keywords || 'ReelCareer, blog, career, jobs');
    updateMetaTag('author', blogData.author || 'ReelCareer Team');

    // Open Graph (OG) meta tags for social media sharing
    updateMetaTag('og:title', `ReelCareer.co | Blog: ${blogData.title}`, true);
    updateMetaTag('og:description', blogData.description || 'Discover this blog post on ReelCareer.co!', true);
    updateMetaTag('og:image', blogData.image || 'https://reelcareer.co/images/default-blog-thumbnail.png', true);
    updateMetaTag('og:url', blogData.url || window.location.href, true);
    updateMetaTag('og:type', 'article', true);

    // Twitter card meta tags
    updateMetaTag('twitter:card', 'summary_large_image');
    updateMetaTag('twitter:title', `ReelCareer.co | Blog: ${blogData.title}`);
    updateMetaTag('twitter:description', blogData.description || 'Check out this blog post on ReelCareer!');
    updateMetaTag('twitter:image', blogData.image || 'https://reelcareer.co/images/default-blog-thumbnail.png');
}







// Initial call to fetch total posts and blogs for the first page
window.onload = async function () {
    try {

    } catch (error) {
        console.error("Error during initialization:", error);
    }
};

*/

    </script>


    
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>
