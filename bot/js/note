// Function in brain.js that you want to call later

  


   
        // Categories and keywords
        const categories = {
           
            money: ['money', 'income', 'wage', 'earnings', 'cost', 'revenue', 'expenses', 'budget', 'finance', 'financial'],
            numbers: ["number", "digit", "quantity", "count", "figure", "value", "total", "sum", "amount", "statistic", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine"],

            compare: ['like', 'same','better', 'worse', 'higher', 'lower', 'greater', 'less', 'equal', 'more', 'fewer', 'increase', 'decrease'],
            conversation: ["talk", "chat", "speak", "discuss", "converse", "dialogue", "exchange", "communication", "interaction", "discussion", "conversing", "message", "question", "answer", "reply", "respond", "gather", "meeting", "meeting up", "speak up", "talking", "conversation"],
            sports: ["sport", "game", "team", "player", "match", "competition", "athlete", "league", "coach", "training", "goal", "score", "winning", "losing", "tournament", "championship", "referee", "fan", "stadium", "arena", "football", "basketball", "soccer", "baseball", "hockey", "tennis", "running", "swimming", "boxing", "wrestling", "volleyball", "rugby", "cycling", "gymnastics", "track", "field", "exercise", "workout"],
            shopping: ["buy", "purchase", "store", "shop", "sale", "discount", "coupon", "offer", "price", "expensive", "cheap", "cost", "market", "mall", "checkout", "cart", "product", "goods", "clothes", "shoes", "electronics", "accessories", "fashion", "shopping", "retail", "online", "shopper", "customer", "storefront", "brand", "deal", "bargain", "item", "order", "transaction"],
            people: ["person", "individual", "human", "people", "family", "friend", "relative", "acquaintance", "colleague", "neighbor", "stranger", "group", "crowd", "team", "community", "society", "audience", "member", "citizen", "resident", "tourist", "employee", "employer", "leader", "follower", "adult", "child", "teenager", "elder", "man", "woman", "boy", "girl", "couple", "parent", "sibling", "partner"],
            occupation: ["job", "career", "work", "profession", "employee", "employer", "occupation", "role", "position", "job title", "workplace", "office", "salary", "pay", "hourly", "freelance", "contract", "full-time", "part-time", "intern", "manager", "director", "supervisor", "staff", "worker", "entrepreneur", "business owner", "contractor", "consultant", "technician", "specialist", "designer", "developer", "engineer", "teacher", "nurse", "doctor", "lawyer", "developer", "writer"],
            holidays: ["holiday", "vacation", "break", "trip", "celebration", "season", "festivity", "celebrate", "party", "holiday season", "christmas", "new year", "thanksgiving", "easter", "summer vacation", "winter holiday", "spring break", "fall break", "public holiday", "national holiday", "long weekend", "tourism", "getaway", "journey", "trip", "travel", "destination", "holiday resort", "traveling", "staycation", "holiday destination", "festival"],
            testing: ["test", "exam", "quiz", "assessment", "evaluation", "check", "trial", "experiment", "survey", "analysis", "questionnaire", "test case", "testing", "assessment", "feedback", "score", "results", "marks", "pass", "fail", "rating", "grade", "measure", "verify", "review", "validate", "analysis", "study", "experimentation", "result", "sample", "sample size", "benchmark"],
            resume: ["resume", "CV", "curriculum vitae", "job application", "cover letter", "qualification", "experience", "education", "skills", "references", "professional", "career", "job history", "work experience", "profile", "career summary", "objective", "accomplishments", "certification", "portfolio", "application", "job seeker", "candidate", "job candidate", "summary", "employment history", "contact information", "personal details", "interests", "achievements", "skills"],
            interview: ["interview", "question", "answer", "panel", "hiring", "recruitment", "candidate", "applicant", "job interview", "selection", "screening", "interviewee", "interviewer", "interview questions", "resume", "behavioral interview", "technical interview", "phone interview", "video interview", "group interview", "one-on-one", "follow-up", "evaluation", "feedback", "offer", "discussion", "negotiation", "job offer", "rejection", "acceptance", "hire"],
            jobPosting: ["job posting", "job ad", "advertisement", "hiring", "career opening", "vacancy", "position", "job opportunity", "career opportunity", "employment", "work", "job description", "listing", "recruitment", "job opening", "staffing", "company", "recruitment ad", "job listing", "career announcement", "career page", "job vacancy", "new hire", "application", "job search", "post a job", "job board", "company career", "job seekers", "search for jobs"],          
            question: ['who', 'what', 'where', 'when', 'why', 'how', '?'],
            request: ['please', 'can you', 'could you', 'i need', 'would you', 'help', 'show me', 'tell me'],
            statement: ['is', 'am', 'are', 'was', 'were', 'will', 'it', 'this', 'that', '.', 'I'],
        
            math: ['salary', 'pay', 'annual', 'monthly', 'sum', 'add', 'subtract', 'multiply', 'divide', '+', '-', '*', '/'],
            quantity: ['much', 'many', 'few', 'several', 'lot', 'amount', 'count', 'number', 'how much', 'how many', 'volume'],
            verbs: ['is', 'are', 'was', 'were', 'be', 'being', 'been'], // Words serving as linking verbs or auxiliary verbs
            determiners: ['this', 'that', 'these', 'those', 'a', 'an', 'the', 'any', 'some'], // Words that specify nouns
            pronouns: ['it', 'he', 'she', 'they', 'we', 'you','i', 'I', 'me', 'us', 'them', 'him', 'her'],
            title: [
                'title', 'name', 'called', 'label',, 'heading', 
                'caption', 'nickname', 'alias', 'doc name', 
                 'reference name', 'identifier'
            ],
            tag: [
                 'tags',
            ],
            
            description: [
                'description',
           ],
            action: [
                'find', 'search', 'wash','make', 'create', 'build', 'develop', 'work', 'apply', 'find', 'search', 'submit', 'look', 'locate', 'searching', 
                'submit', 'interview', 'complete', 'start', 'create', 'build', 
                'check', 'review', 'post', 'update', 'edit', 'delete', 'organize', 
                'manage', 'plan', 'prepare', 'schedule', 'track', 'verify', 'explore', 
                'read', 'write', 'type', 'develop', 'run', 'fix', 'install', 'remove', 
                'solve', 'handle', 'support', 'deliver', 'connect', 'contact', 'send', 
                'receive', 'share', 'move', 'navigate', 'select', 'choose', 'pick', 
                'upload', 'download', 'save', 'process', 'apply for', 'hire', 'recruit', 
                'train', 'test', 'evaluate', 'calculate', 'measure', 'examine', 'gather', 
                'execute', 'improve', 'enhance', 'launch', 'implement', 'monitor', 
                'oversee', 'collaborate', 'follow', 'lead', 'respond', 'click', 'scroll', 
                'buy', 'sell', 'search for', 'clean', 'design', 'research', 'submit for', 
                'approve', 'decline', 'accept', 'report', 'assist', 'present', 'attend', 
                'join', 'register', 'apply to', 'log in', 'sign up', 'sign in', 'reset', 
                'activate', 'customize', 'update profile', 'post job', 'take', 'give', 
                'focus', 'skip', 'cancel', 'analyze', 'compare', 'rank', 'sort', 'filter',
                'optimize', 'rearrange', 'evaluate', 'write down', 'fill in', 'fill out',
                'ask', 'answer', 'teach', 'learn', 'coach', 'request', 'download file',
                'approve request', 'add', 'add to', 'remove from', 'clear', 'backup',
                'replace', 'pause', 'resume', 'stop', 'start over', 'retry', 'sync'
            ],
            dataBaseTerms: [
                'firebase', 'firestore', 'database', 
                'document', 'collection', 'field', 'snapshot', 'query', 'set', 'get', 
                'update', 'delete', 'add', 'push', 'doc', 'collection group', 'reference', 
                'where', 'orderBy', 'limit', 'orderByChild', 'orderByKey', 'orderByValue', 
                'transaction', 'batch', 
                'fieldValue', 'serverTimestamp', 'arrayUnion', 'arrayRemove', 'increment', 
                 'setDoc', 'getDoc', 'updateDoc', 'deleteDoc', 'writeBatch', 
                
            ],
                // Set document (overwrite a document completely or create a new one)
    setDocument: [
        'set', 'setDoc','setDocs', 'set document', 'overwrite', 'create new', 'update completely', 
        'save document', 'write document', 'initialize', 'write data', 'add new data',
        'document creation', 'replace document'
    ],

    // Add document (add a new document to a collection)
    addDocument: [
        'add', 'addDoc', 'addDocs', 'add document', 'create', 'insert', 'insert document', 
        'push document', 'add new record', 'append document', 'new entry', 'new document',
        'document addition', 'add record', 'submit new doc', 'create new record', 
        'push data', 'create entry'
    ],

    // Update document (modify an existing document)
    updateDocument: [
        'update', 'updateDoc', 'updateDocs', 'modify', 'change document', 'edit document', 'update fields', 
        'change fields', 'update data', 'document edit', 'edit record', 'modify data', 
        'alter document', 'update information', 'update record', 'patch document', 
        'document modification', 'change record', 'revise document', 'update details'
    ]
        };
        
        
        
    



        const categoryKeys = Object.keys(categories);

        console.log(categoryKeys);
        


// Tokenize the input, including math symbols and numbers
function tokenize(input) {
    const regex = /[\w'-?]+|[+\-*/()]|[\d,.]+/g; // Match words, numbers, math symbols, and '?'
    return input.match(regex) || [];
}





// Detect and evaluate math-related queries
function detectAndEvaluateMath(tokens) {
const mathTokens = [];
let containsMathSymbol = false;

tokens.forEach(token => {
if (categories.math.includes(token) || token.match(/[+\-*/]/)) {
    containsMathSymbol = true; // Math-related symbol detected
}
mathTokens.push(token); // Add to potential math expression
});

// If math symbols or terms are detected, evaluate the math expression
if (containsMathSymbol) {
try {
    const mathExpression = mathTokens.join(' ').replace(/,/g, ''); // Join tokens into a valid expression
    const result = eval(mathExpression); // Safely evaluate the expression
    return `The result of your calculation (${mathExpression}) is ${result.toFixed(2)}.`;
} catch (error) {
    return "I couldn't evaluate that expression. Please check your input.";
}
}
return null; // No math-related input detected
}




// Detect salary queries
function detectSalaryQuery(tokens) {
let salary = null;
let keyword = null;

tokens.forEach(token => {
if (token.match(/^\$?\d{1,3}(?:,\d{3})*(?:\.\d+)?$/)) { // Detect currency values
    salary = parseFloat(token.replace(/[^0-9.-]+/g, "")); // Clean and convert to number
}
if (categories.math.includes(token)) {
    keyword = token;
}
});

return { salary, keyword };
}



// Normalize locations by matching location abbreviations and full names
function normalizeLocations(tokens, categories) {
return tokens.map(token => {
console.log("tokens:", tokens);
// Check if the token matches a state abbreviation
const normalizedToken = categories[token.toUpperCase()];
if (normalizedToken) {
    return normalizedToken.toLowerCase(); // Normalize state names to lowercase
}

// Check if the token matches a state name
const foundState = Object.values(categories.states).find(state => 
    state.toLowerCase() === token.toLowerCase()
);
if (foundState) {
    return foundState.toLowerCase(); // Normalize full state names to lowercase
}

// Return the token unchanged if not a state
return token;
});
}



// Implement basic fuzzy matching using Levenshtein distance
function fuzzyMatch(word, categoryWords, threshold = 0.8) {
const matches = categoryWords.filter(categoryWord => {
const similarity = calculateLevenshteinDistance(word, categoryWord);
const maxLength = Math.max(word.length, categoryWord.length);
return (similarity / maxLength) >= threshold;  // Return words that are at least 80% similar
});
return matches;
}

// Function to calculate Levenshtein distance between two words
function calculateLevenshteinDistance(a, b) {
const tmp = [];
for (let i = 0; i <= b.length; i++) {
tmp[i] = [i];
}
for (let i = 0; i <= a.length; i++) {
tmp[0][i] = i;
}
for (let i = 1; i <= a.length; i++) {
for (let j = 1; j <= b.length; j++) {
    tmp[j][i] = Math.min(
        tmp[j - 1][i] + 1,
        tmp[j][i - 1] + 1,
        tmp[j - 1][i - 1] + (a[i - 1] === b[j - 1] ? 0 : 1)
    );
}
}
return tmp[b.length][a.length];
}

// Expand synonyms by using fuzzy matching
function expandSynonyms(tokens, category, categories) {
return tokens.map(token => {
if (categories[category]) {
    const matches = fuzzyMatch(token, categories[category]);
    if (matches.length > 0) {
        return matches[0]; // Return the first match
    }
}
return token;  // Return token as-is if no match found
});
}

// Categorize tokens into predefined categories and return both category and word
function categorizeTokens(tokens, categories) {
    const mappedWords = [];

    tokens.forEach(token => {
        // Match against each category
        Object.keys(categories).forEach(category => {
            const categoryValues = categories[category];
            
            if (category === 'states') {
                // Check if token matches any state abbreviation or full name
                const regexState = new RegExp('\\b(' + Object.keys(categoryValues).join('|') + ')\\b', 'i');
                if (regexState.test(token) || Object.values(categoryValues).map(state => state.toLowerCase()).includes(token.toLowerCase())) {
                    mappedWords.push({ category: category, word: token });
                }
            } else if (Array.isArray(categoryValues) && categoryValues.includes(token)) {
                mappedWords.push({ category: category, word: token });
            }
        });
    });

    return mappedWords;
}





function prioritizeCategories(tokens, categorizedTokens, userPreferences = {}) { 
   /*
   
    console.log("prioritizeCategories=====================================, "); 
    console.log("categorizedTokens, ", categorizedTokens); 
    console.log( "userPreferences,", userPreferences); 
    console.log("tokens, ", tokens); 
*/
    // Default priorities for categories
    const priorities = getDefaultPriorities();

    // Adjust priorities based on user preferences (e.g., favorite categories)
    adjustPrioritiesForUserPreferences(priorities, userPreferences);

    // Adjust priorities based on the input type (e.g., question, request, or statement)
    adjustPrioritiesByInputType(categorizedTokens, tokens, priorities);

    // Handle emotion-based prioritization if the input contains sentiment/emotion words
    handleEmotionPrioritization(categorizedTokens, priorities);

    getWeightAdjustmentFactor(tokens);
    // Adjust priorities if the query involves an action
    prioritizeActionTokens(categorizedTokens, tokens, priorities);

    // Sort tokens based on the adjusted priorities
    const sortedTokens = sortTokensByPriority(categorizedTokens, priorities);

    return sortedTokens[0]; // Return the highest-priority match
}

// Get default priorities for categories
function getDefaultPriorities() {
    let prioritiesCount = 0;

    return {
        // Auto-incremented priorities
        action: prioritiesCount, // Assign the highest priority to action by default

        setDocument: prioritiesCount++,
        addDocument: prioritiesCount++,
        updateDocument: prioritiesCount++,

        generalInquiry: prioritiesCount++,
        question: prioritiesCount++,
    
        
        dataBaseTerms: prioritiesCount++,

        jobSearch: prioritiesCount++,
        jobRelated: prioritiesCount++,

        title: prioritiesCount++,
        tag: prioritiesCount++,
        description: prioritiesCount++,
        math: prioritiesCount++,

        location: prioritiesCount++,
        time: prioritiesCount++,
        salary: prioritiesCount++,

        websiteSupport: prioritiesCount++,
        conversation: prioritiesCount++,

        vehicle: prioritiesCount++,
        jobCategories: prioritiesCount++,
        events: prioritiesCount++,
        technology: prioritiesCount++,
        health: prioritiesCount++,
        emotions: prioritiesCount++,
        experience: prioritiesCount++,
        benefit: prioritiesCount++,
        company: prioritiesCount++,
        preferences: prioritiesCount++,
        relationships: prioritiesCount++,
        payments: prioritiesCount++,
        feedback: prioritiesCount++,
    };
}

// Adjust priorities based on user preferences (e.g., favorite categories)
function adjustPrioritiesForUserPreferences(priorities, userPreferences) {
    if (userPreferences && userPreferences.favoriteCategories) {
        userPreferences.favoriteCategories.forEach(category => {
            priorities[category] = 1; // Give priority to favorite categories
        });
    }
}

// Adjust priorities dynamically based on the input type (e.g., question, request, or statement)
let userPreferences = {};

function adjustPrioritiesByInputType(categorizedTokens, tokens) {
    console.log("tokens:", tokens);

    const categoryWeights = {};

    categorizedTokens.forEach(({ category }) => {
        categoryWeights[category] = (categoryWeights[category] || 1) * 1.5;
    });

    const favoriteCategories = Object.entries(categoryWeights)
        .sort(([, weightA], [, weightB]) => weightB - weightA)
        .map(([category]) => category);

    userPreferences = { favoriteCategories };

    console.log("Updated User Preferences:", userPreferences);
    return categorizedTokens.map(token => ({
        ...token,
        weight: categoryWeights[token.category] || 1
    }));
}

// Return a dynamic weight adjustment factor based on the input type
function getWeightAdjustmentFactor(inputType) {
    const factors = {
        question: 0.8,
        request: 1.2,  // Requests could have slightly higher priority (e.g., 'task' and 'payments')
        statement: 1.0,
        emotion: 0.9  // Emotion-related inputs could be weighted slightly lower
    };

    return factors[inputType] || 1;  // Default to 1 if inputType is not found
}

// Handle emotion-based prioritization if the input contains sentiment/emotion words
function handleEmotionPrioritization(categorizedTokens, priorities) {
    const emotionCategories = ['excitement', 'frustration', 'hope', 'regret'];
    categorizedTokens.forEach(token => {
        if (emotionCategories.includes(token.category)) {
            priorities.emotions = 1; // High priority if emotions are involved
        }
    });
}

// Adjust priorities if the query involves an action
function prioritizeActionTokens(categorizedTokens, inputType, priorities) {
    const actionToken = categorizedTokens.find(token => token.category === 'action');
    if (actionToken) {
        priorities.action = 0; // Override with highest priority if action is involved
    }

    // Prioritize action over other categories like technology, unless it's a question involving technology
    categorizedTokens.forEach(token => {
        if (actionToken && token.category === 'technology' && inputType === 'question') {
            priorities.technology = 2; // Reduce priority for technology in questions unless it's a direct match
        }
    });
}

// Sort tokens based on the adjusted priorities
function sortTokensByPriority(categorizedTokens, priorities) {
    return categorizedTokens.sort((a, b) => {
        return (priorities[a.category] || 99) - (priorities[b.category] || 99);
    });
}





// **Handle Job Search Query Logic:**


async function handleJobQuery( tokens,categorizedTokens, userPreferences) {
    try {

        const lowerTokens = tokens
    .map(t => t.trim().toLowerCase())
    .slice(0, 10); // Limit the array to the first 10 tokens

        const bestMatch = prioritizeCategories(tokens,categorizedTokens, userPreferences );

        console.log("bestMatch ",bestMatch); 
        

    //"question" | "request" | "self-reference" | "other-reference" | "statement"
    
    




        let constraints = []; // Holds query constraints
        
        // 1. Handle Requests/Actions with Specific Words
        if (bestMatch.word === 'create' || bestMatch.category === 'dataBaseTerms' || bestMatch.category === 'setDocument' || 
            bestMatch.category === 'addDocument' || bestMatch.category === 'updateDocument' || 

            bestMatch.category === 'request' || bestMatch.category === 'action') {
            const actionWords = ['please', 'can', 'can you', 'i need', 'would you', 'help', 
                                 'show me', 'create', 'build', 'edit', 'review', 'check',
                                 'fix', 'save', 'add', 'remember', 'enhance', 'improve'];
            
            // Check if tokens match any of the action words
            const matchedActions = tokens.filter(word => actionWords.includes(word.toLowerCase()));

            console.log(`categorizedTokens ${categorizedTokens} `);
       
            
            console.log(`bestMatch.word ${bestMatch.word} `);
            console.log(`tokens for creating ${tokens} `);
            console.log(`matchedActions for creating ${matchedActions} `);

            const  learningModel_DB =  'z_LearningModel';

        
            
                handleLearningModelRequest(bestMatch, matchedActions, tokens, 
                    categorizedTokens, constraints, learningModel_DB);


                    
        }



        if (bestMatch.category === 'question' || bestMatch.category === 'generalInquiry') {
            const questionWords = ['who', 'what', 'where', 'when', 'why', 'how', '?'];
            
                        
            const inquiryWords = ['question', 'how', 'why', 'where', 'what', 'when', 'which', 'can', 'could', 'would', 'do', 'did', 
                'is', 'are', 'am', 'will', 'should', 'where can', 'what is', 'who', 'any', 'anyone', 'anybody', 
                'tell me', 'explain', 'information', 'inquire', 'ask', 'help', 'clarify', 'describe', 'details', 
                'understand', 'learn', 'suggest', 'recommend', 'advice', 'guide', 'directions', 'steps', 'assistance', 
                'know', 'need', 'looking for', 'looking to', 'interested in', 'how to', 'where to', 'is it possible', 
                'help me', 'can you explain', 'what do you mean', 'can you tell me'];
            
            // Check if tokens match any of the action words
            const matchedQuestion = tokens.filter(word => questionWords.includes(word.toLowerCase()));
            const matchedInquiry = tokens.filter(word => inquiryWords.includes(word.toLowerCase()));

            console.log(`categorizedTokens ${categorizedTokens} `);
            console.log(`bestMatch.word ${bestMatch.word} `);
            console.log(`tokens for creating ${tokens} `);
            console.log(`matchedQuestion for creating ${matchedQuestion} `);
            console.log(`matchedInquiry for creating ${matchedInquiry} `);

            const  learningModel_DB =  'z_LearningModel';

  

            handleLearningModelQuery(bestMatch, matchedQuestion,matchedInquiry  , tokens, 
                categorizedTokens, constraints, learningModel_DB);

         

            return `I cee you have a  ${bestMatch.category} about ${tokens}, i will check in ${learningModel_DB}`
        }


 
        

            
      
        



    
        // Handle location-based searches (e.g., "jobs in New York")
        if (bestMatch.category === 'location' || bestMatch.category === 'states') {
            const location = normalizeLocations(tokens, categories);
            return fetchJobData(location);
        }
    
    
        // Category: Job Categories
        if (bestMatch.category === 'jobCategories') {
            const jobCategory = bestMatch.word;
            return fetchJobsByCategory(jobCategory);
        }

        // Category: Benefits
        if (['benefit', 'travel', 'health', 'vehicle', 'technology', 'education'].includes(bestMatch.category) &&
            ['job', 'company', 'food', 'hotel', 'travel', 'benefit', 'training', 'insurance', 'health'].includes(bestMatch.word)) {
            return fetchJobsByBenefits(lowerTokens);
        }

        // Category: Date/Time (New Jobs)
        if (['jobSearch', 'jobRelated', 'jobCategories'].includes(bestMatch.category) &&
            ['new', 'current', 'today', 'this week', 'this month'].includes(bestMatch.word)) {
            return fetchJobsByDate(bestMatch.word);
        }

        // Category: Industry
        if (bestMatch.category === 'industry') {
            const industry = bestMatch.word;
            return fetchJobsByIndustry(industry);
        }

        // Category: Requirements (Education, Experience, Skills)
        if (['education', 'experience', 'task'].includes(bestMatch.category) &&
            ['college', 'certificate', 'training', 'course', 'assessment', 'years', 'experience', 'project', 'duties', 'skills', 'talents', 'task', 'plan'].includes(bestMatch.word)) {
            return fetchJobsByRequirements(lowerTokens);
        }

        // Category: Title/Position
        if (['jobSearch', 'jobRelated', 'jobCategories'].includes(bestMatch.category) &&
            ['job', 'role', 'position', 'title', 'career', 'opportunity', 'employment'].includes(bestMatch.word)) {
            return fetchJobsByTitle(lowerTokens);
        }

        // Category: Job Count/Location
        if (['state', 'location'].includes(bestMatch.category) &&
            ['count', 'total', 'job count', 'job total', 'how', 'many'].includes(bestMatch.word)) {
            return fetchJobCountByLocation(lowerTokens);
        }

        // Category: Salary
        if (bestMatch.category === 'salary') {
            const salary = detectSalaryFromTokens(lowerTokens);
            return filterJobsBySalary(salary);
        }
 
        // Handle salary-related queries (e.g., "jobs that pay over $50,000")
  if (bestMatch.category === 'salary') {
    const salary = detectSalaryQuery(tokens);
    return filterJobsBySalary(salary);
}

        // Handle job-related queries (e.g., "jobs in [location]")
        if (bestMatch && bestMatch.category === 'jobSearch') {
        
            const location = lowerTokens.filter(token => 
                categories.location.includes(token) || 
                Object.values(categories.states).includes(token)
            ).join(' ') || 'all locations';
        
            const jobType = lowerTokens.filter(token => 
                categories.jobCategories.some(job => job.includes(token))
            ).join(' ') || 'all jobs';
        
            console.log('Location:', location, 'Job Type:', jobType);
            return fetchJobData({ location, jobType });
        }



        // Default: No Match
        return "No matching query criteria were found.";

    } catch (error) {
        console.error("Error handling job query:", error);
        return "An error occurred while processing the query.";
    }
}




import {
    db, getStorage, ref, uploadBytes, getDownloadURL, limit,
  doc, arrayUnion, RecaptchaVerifier, increment, getDoc, arrayRemove, signInWithPhoneNumber,
  query, updateDoc, setDoc, addDoc, signInAnonymously, orderBy, onAuthStateChanged,
  uploadBytesResumable, signInWithPopup, FacebookAuthProvider, GoogleAuthProvider, startAfter,
  OAuthProvider, signOut, deleteDoc, getFirestore, serverTimestamp,
  createUserWithEmailAndPassword, signInWithEmailAndPassword, deleteObject,
  where, getDocs, storage, getAuth, collection, auth, analytics, 
  googleProvider,onSnapshot ,  batch,
  facebookProvider,writeBatch ,
  getUserId // Export the function
  } from 'https://reelcareer.co/scripts/js/load/module.js';
  
  
  


// **Helper Functions for Fetching Job Data:**

async function fetchJobData({ location, jobType }) {
    try {
        // Create a base query on the 'Jobs' collection
        let jobQuery = collection(db, 'Jobs'); 
        
        // Array to hold query constraints
        let constraints = [];

        // Add query constraints based on input parameters
        if (location) {
            constraints.push(where('location', 'array-contains-any', location));
        }

        if (jobType) {
            constraints.push(where('category', '==', jobType));
        }

        // Combine query constraints
        const finalQuery = query(jobQuery, ...constraints);

        // Fetch data
        const snapshot = await getDocs(finalQuery);
        const jobs = snapshot.docs.map(doc => doc.data());

        // Return the result message
        if (jobs.length > 0) {
            return `Found ${jobs.length} job(s) matching your criteria.`;
        } else {
            return "No jobs found for your search criteria.";
        }

    } catch (error) {
        console.error("Error fetching job data:", error);
        return "Sorry, there was an error fetching job data.";
    }
}


async function fetchJobsByCategory(category) {
    const jobQuery = query(collection(db, 'Jobs'), where('category', '==', category));
    return executeQuery(jobQuery, `Jobs in category: ${category}`);
}


async function fetchJobsByBenefits(tokens) {
    const jobQuery = query(collection(db, 'Jobs'), where('benefits', 'array-contains-any', tokens));
    return executeQuery(jobQuery, `Jobs with benefits matching: ${tokens.join(', ')}`);
}


async function fetchJobsByDate(dateFilter) {
    const currentTime = new Date();
    let startDate;

    if (dateFilter === 'today') {
        startDate = new Date(currentTime.setHours(0, 0, 0, 0));
    } else if (dateFilter === 'this week') {
        startDate = new Date();
        startDate.setDate(currentTime.getDate() - 7);
    } else if (dateFilter === 'this month') {
        startDate = new Date(currentTime.getFullYear(), currentTime.getMonth(), 1);
    }

    const jobQuery = query(collection(db, 'Jobs'), where('createdAt', '>=', startDate));
    return executeQuery(jobQuery, `Jobs posted since ${dateFilter}`);
}

async function fetchJobsByIndustry(industry) {
    const jobQuery = query(collection(db, 'Jobs'), where('industry', '==', industry));
    return executeQuery(jobQuery, `Jobs in the industry: ${industry}`);
}


async function fetchJobsByRequirements(tokens) {
    const jobQuery = query(collection(db, 'Jobs'), where('searchableRequirements', 'array-contains-any', tokens));
    return executeQuery(jobQuery, `Jobs matching requirements: ${tokens.join(', ')}`);
}


async function fetchJobsByTitle(tokens) {
    const jobQuery = query(collection(db, 'Jobs'), where('searchableTitle', 'array-contains-any', tokens));
    return executeQuery(jobQuery, `Jobs matching titles: ${tokens.join(', ')}`);
}

async function fetchJobCountByLocation(tokens) {
    const jobQuery = query(collection(db, 'Jobs'), where('location', 'array-contains-any', tokens));
    const snapshot = await getDocs(jobQuery);
    return `Found ${snapshot.size} jobs in location(s): ${tokens.join(', ')}`;
}

async function filterJobsBySalary(salary) {
    const jobQuery = query(collection(db, 'Jobs'), where('salary', '>=', salary));
    return executeQuery(jobQuery, `Jobs paying over $${salary}`);
}

function detectSalaryFromTokens(tokens) {
    const salary = tokens.find(token => /^\d+$/.test(token)); // Extract numeric token
    return salary ? parseInt(salary, 10) : null;
}

async function executeQuery(jobQuery, message) {
    try {
        const snapshot = await getDocs(jobQuery);
        const jobs = snapshot.docs.map(doc => doc.data());

        if (jobs.length > 0) {
            return `${message}: Found ${jobs.length} job(s).`;
        } else {
            return `${message}: No jobs found.`;
        }
    } catch (error) {
        console.error("Error executing query:", error);
        return "An error occurred while fetching job data.";
    }
}














// Predefined sets for faster lookups
const questionWords = new Set(['what', 'how', 'why', 'when', 'where', 'who', 'which']);
const requestVerbs = new Set(['calculate', 'show', 'help', 'find', 'get', 'give']);

const selfPronouns = new Set(['i', 'me', 'my', 'mine', 'myself']);
const otherPronouns = new Set(['you', 'your', 'yours', 'he', 'she', 'they', 'them', 'their', 'theirs', 'him', 'her']);

/**
 * Function to determine the input type based on tokens.
 * @param {string[]} tokens - Array of input words.
 * @returns {string} - Type of input: 'question', 'request', 'self-reference', 'other-reference', or 'statement'.
 */
function determineInputType(tokens) { 
    // Validate input
    if (!Array.isArray(tokens) || tokens.length === 0) return 'statement';

    // Normalize tokens to lowercase
    const lowerTokens = tokens.map(token => token.toLowerCase());

    // Check for a question
    if (lowerTokens.some(token => questionWords.has(token)) || tokens.join(' ').trim().endsWith('?')) {
        return 'question';
    }

    // Check for a request
    if (lowerTokens.some(token => requestVerbs.has(token))) {
        return 'request';
    }

    // Check for self-references
    if (lowerTokens.some(token => selfPronouns.has(token))) {
        return 'self-reference';
    }

    // Check for references to others
    if (lowerTokens.some(token => otherPronouns.has(token))) {
        return 'other-reference';
    }

    // Default to statement
    return 'statement';
}






function processMessage(message) {
const userInput = message.toLowerCase();
let tokens = tokenize(userInput);

// 1. Handle math expressions
const mathResponse = detectAndEvaluateMath(tokens);
if (mathResponse) {
return `Here's your result: ${mathResponse}`;
}




//console.log("tokens:", tokens);

// 3. Categorize tokens
//tokens = normalizeLocations(tokens, categories);
const categorizedTokens = categorizeTokens(tokens, categories);
//console.log("categorizedTokens:", categorizedTokens);











// 5. Dynamic response based on context
const inputType = determineInputType(tokens, categories);

console.log("userPreferences:", inputType);




async function fetchJobQueryAndDisplay() {
    try {
        // Wait for handleJobQuery to resolve
        let JobQuery = await handleJobQuery(tokens, categorizedTokens, userPreferences = inputType);


        
        // Add a 3-second delay before calling displayMessage
        if (JobQuery) {
            setTimeout(async () => {
                await displayMessage("bot", JobQuery); // Call displayMessage with 'bot' as sender
             //   console.log("JobQuery Result Sent:", JobQuery); // Log the sent message
            }, 3000); // 3-second delay
        }
    } catch (error) {
        console.error("Error in JobQuery:", error);
    }
}

// Trigger the function
fetchJobQueryAndDisplay();



}

window.processMessage  = processMessage ;






function validateTokenCategorization(tokens, categorizedTokens) {
    // Extract unique words from categorizedTokens
    const categorizedWords = [...new Set(categorizedTokens.map(item => item.word))];

    // If lengths match, return "ready"
    if (tokens.length === categorizedTokens.length) {
        return "READY";
    }

    // Compare categorized words with tokens to find missing words
    const missingWords = tokens.filter(token => !categorizedWords.includes(token));

    // Return the missing words array directly
    return missingWords.length > 0 ? missingWords : "READY";
}

async function createButtons(type, termsArray, containerId, btnType) {
    // Get the container where buttons will be added
    const container = document.getElementById(containerId);

    // Clear the container to avoid duplicates
    container.innerHTML = '';

    // Loop through each term in the array
    termsArray.forEach(term => {
        // Create a button element
        const button = document.createElement('button');

        // Set button text and attributes
        button.innerText = term;
        button.className = 'dynamic-button'; // Optional: Add a class for styling
        button.dataset.term = term; // Store term for reference

        // Add event listener to the button
        button.addEventListener('click', async (e) => { // Mark this function as async to use await
            if(btnType === "FromTerms"){

                // Handle the setDocs action
                if ("setDocument" === type) {
                    const docId = e.target.dataset.term;
                    console.log("Setting a new document...");
                    // Await the setDoc function call and handle the result
                    const result = await setDocFunc(learningModel_DB, docId);
                    console.log(result); // Optionally log the result
                }
            
                // Handle the updateDocs action
                if ("updateDocument" === type) {
                    const docId = e.target.dataset.term;
                    console.log("Updating an existing document...");
                    // Await the updateDoc function call and handle the result
                    const result = await updateDocFunc(learningModel_DB, docId);
                    console.log(result); // Optionally log the result
                }
                if ("addDocument" === type) {
                    const docId = e.target.dataset.term;
                    console.log("Add new document...");
                    // Await the setDoc function call and handle the result
                    const result = await addDocFunc(learningModel_DB, docId);
                    console.log(result); // Optionally log the result
                }
                console.log(`FromTerms Button clicked: ${e.target.dataset.term}`);
            }

            // Show toast with the clicked term
            showToast(`You clicked on: ${e.target.dataset.term}`);
        });

        // Append the button to the container
        container.appendChild(button);
    });
}



async function checkIfDocumentExists(docId, collectionName) {
    try {
        // Reference to the Firestore document
        const docRef = db.collection(collectionName).doc(docId);

        // Get the document snapshot
        const docSnapshot = await docRef.get();

        // Check if the document exists
        if (docSnapshot.exists) {
            console.log(`Document with ID '${docId}' exists.`);
            return true;
        } else {
            console.log(`Document with ID '${docId}' does not exist.`);
            return false;
        }
    } catch (error) {
        console.error("Error checking document existence: ", error);
        return false;
    }
}



async function addDocFunc(learningModel_DB, docId, tokens) {
    const actionWords = [
        'add', 'addDoc', 'add document', 'create', 'insert', 'insert document', 
        'push document', 'new entry', 'new document', 'submit new doc', 'create entry'
    ];

    const matchedActions = tokens.filter(word => actionWords.includes(word.toLowerCase()));
    console.log(`Tokens for adding: ${tokens}`);
    console.log(`Matched actions for adding: ${matchedActions}`);

if (matchedActions.length > 0) {
    console.log(`Adding a new document to '${learningModel_DB}' collection`);


console.log("Adding a new document...");


}
    const newDocumentData = {
        directions: tokens.join(' '),
        timestamp: new Date(), // Firestore timestamp or current time
    };

    try {
        const docRef = db.collection(learningModel_DB).doc(docId);
        await docRef.set(newDocumentData);

        console.log(`New document added with ID: ${docRef.id}`);
        return `Document added successfully with ID: ${docRef.id}.`;
    } catch (error) {
        console.error('Error adding document:', error);
        return 'Failed to add the document.';
    }
}










async function updateDocFunc(learningModel_DB, docId, tokens) {

    const actionWords = [
        'update', 'updateDoc', 'modify', 'change document', 'edit document', 'update fields', 
        'change fields', 'update data', 'document edit', 'edit record', 'modify data'
    ];

    const matchedActions = tokens.filter(word => actionWords.includes(word.toLowerCase()));
    console.log(`Tokens for updating: ${tokens}`);
    console.log(`Matched actions for updating: ${matchedActions}`);

   


const results = checkIfDocumentExists(docId, learningModel_DB);

if(!results){
    setTimeout(() => {
        addDocFunc(learningModel_DB, docId, tokens);
    }, 200);
    return " No Doc to Update";
}
    const updatedData = {
        directions: tokens.join(' '),
        timestamp: new Date(), // Firestore timestamp or current time
    };

    try {
        const docRef = db.collection(learningModel_DB).doc(docId);
        await docRef.update(updatedData);
        console.log(`Document with ID '${docId}' updated successfully.`);
        return `Document updated successfully with ID: ${docId}.`;
    } catch (error) {
        console.error('Error updating document:', error);
        return 'Failed to update the document.';
    }
}









async function setDocFunc(docId, learningModel_DB, tokens) {
    // Define action words (can be used for matching or other purposes)
    const actionWords = [
        'set', 'setDoc', 'set document', 'overwrite', 'create new', 'update completely', 
        'save document', 'write document', 'initialize', 'write data', 'add new data',
        'document creation', 'replace document'
    ];

    // Logging the action
    console.log(`Setting a new document in '${learningModel_DB}' collection`);

    // Define learning action data
    const learning_action = {
        searchableDirections: ["create", "build", "edit"],
        directions: tokens.join(' '),
        category: "action",
        description: "Learning actions related to creating, building, and editing documents.",
        keywords: ["can you", "help", "create", "build", "edit"],
        relatedTopics: ["content creation", "document editing"],
        timestamp: new Date(), // Firestore timestamp or current time
    };

    try {
        // Reference to the document in Firestore
        const docRef = db.collection(learningModel_DB).doc(docId);

        // Set the document with the provided data, merging with any existing data
        await docRef.set(
            {
                learning_action: learning_action
            },
            { merge: true } // Merge data with existing document, if any
        );

        console.log(`Document with ID '${docId}' added/updated successfully.`);
    } catch (error) {
        console.error('Error adding/updating document: ', error);
    }
}



async function handleLearningModelRequest(bestMatch, matchedActions, tokens, categorizedTokens, constraints, learningModel_DB) {
    // Extract categories for database terms
    const dataBaseTerms = categorizedTokens.filter(token => token.category === 'dataBaseTerms')[0]?.word;
  
    const setDocument = categorizedTokens.filter(token => token.category === 'setDocument')[0]?.word;
    const addDocument = categorizedTokens.filter(token => token.category === 'addDocument')[0]?.word;
    const updateDocument = categorizedTokens.filter(token => token.category === 'updateDocument')[0]?.word;

    // Log detected terms
    if (dataBaseTerms) {
        console.log(`Detected database term: ${dataBaseTerms}`);
    } 

    if (setDocument) {
        console.log(`Matched setDocument word: ${setDocument}`);
    }

    if (addDocument) {
        console.log(`Matched addDocument word: ${addDocument}`);
    } 

    if (updateDocument) {
        console.log(`Matched updateDocument word: ${updateDocument}`);
    } 


    if (matchedActions.length > 0) {
        console.log(`Matched actions: ${matchedActions}`);
    }
    console.log(`Tokens for processing: ${tokens}`);




    // Actions for 'setDoc' (replace or set the document completely)
    if (setDocument === 'set'|| bestMatch.word === "set") {
       
        

const result = validateTokenCategorization(tokens, categorizedTokens);
console.log(result);

if(result != "READY"){

setTimeout(() => {
    createButtons("setDocument", result, `btnContainer${bestMatch.word}`,"FromTerms",tokens);
}, 200);
}else{

    // create doc
}

    }else  
    // Actions for 'addDoc' (add a new document to the Firestore collection)
    if (addDocument === 'add' || bestMatch.word === "create"
    ) {
  

    const result = validateTokenCategorization(tokens, categorizedTokens);
    console.log(result);
    
    if(result != "READY"){
    
    setTimeout(() => {
        createButtons("addDocument", result, `btnContainer${bestMatch.word}`,"FromTerms",tokens);
    }, 200);
    }else{
    
        // add doc
    }



    }else
    
    // Actions for 'updateDoc' (update an existing document)
    if (updateDocument === 'update' || bestMatch.word === 'update') {

        const result = validateTokenCategorization(tokens, categorizedTokens);
        console.log(result);
        
        if(result != "READY"){
        
        setTimeout(() => {
            createButtons("updateDocument", result, `btnContainer${bestMatch.word}`,"FromTerms",tokens);
        }, 200);
        }else{
        
            // update doc
        }
    }else {

  // Fallback if no condition is met
  console.log('No matching database operation found.');
  return 'Sorry, I could not determine the requested database action.';


    }
  }


  













        
async function handleLearningModelQuery(bestMatch, matchedQuestion,matchedInquiry  , tokens, 
    categorizedTokens, constraints, learningModel_DB){
        try {
        // Reference to the document in the collection
        const docRef = db.collection(learningModel_DB).doc(docId);

        // Get the document snapshot
        const docSnapshot = await docRef.get();

        if (docSnapshot.exists) {
            // Retrieve the 'directions' array
            const data = docSnapshot.data();
            const directionsArray = data.directions || []; // Default to an empty array if 'directions' doesn't exist

            console.log("Directions Array:", directionsArray);

            // Optional: Loop through the array to display key-value pairs
            directionsArray.forEach((item, index) => {
                console.log(`Item ${index + 1}: Key = ${item.key}, Value = ${item.value}`);
            });

            return directionsArray;
        } else {
            console.log(`No document found with ID '${docId}'.`);
            return [];
        }
    } catch (error) {
        console.error("Error reading document: ", error);
        return [];
    }
}




