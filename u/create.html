<!DOCTYPE html>
<html lang="en">
  <head>
    <!-- Basic Meta Tags -->
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Discover job seekers' video resumes on ReelCareer. Browse video reels, connect with candidates, and hire talent with ease.">
    <meta name="keywords" content="video resumes, job seekers, career videos, hire talent, video profiles, professional videos, job board, employment videos, ReelCareer">
    <meta name="author" content="ReelCareer">
    <meta name="robots" content="index, follow">
    <meta name="language" content="en-US">
    <meta name="geo.region" content="US-TX">
    <meta name="geo.placename" content="Dallas, Texas">

    <!-- Title -->
    <title>Explore Video Resumes | ReelCareer Job Board</title>

    <!-- Open Graph Meta Tags -->
    <meta property="og:title" content="Explore Job Seekers' Video Resumes | ReelCareer">
    <meta property="og:description" content="Watch professional video resumes and connect with top candidates on ReelCareer's job board. Simplify your hiring process.">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://www.reelcareer.co/reels">
    <meta property="og:image" content="https://www.reelcareer.co/images/sq_logo_n_BG_tie_reelx.png">
    <meta property="og:site_name" content="ReelCareer">
    <meta property="og:locale" content="en_US">

    <!-- Twitter Card Meta Tags -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@ReelCareer">
    <meta name="twitter:title" content="Discover Video Resumes | ReelCareer">
    <meta name="twitter:description" content="Browse professional video resumes, connect with candidates, and streamline your hiring process with ReelCareer.">
    <meta name="twitter:image" content="https://www.reelcareer.co/images/sq_logo_n_BG_tie_reelx.png">

  <!-- Canonical Tag for SEO -->
  <link rel="canonical" href="https://www.reelcareer.co/reels">

  <!-- Standard Favicon -->
  <link rel="icon" type="image/x-icon" href="https://www.ReelCareer.co/images/favicons/favicon.ico">

  <!-- 32x32 Favicon -->
  <link rel="icon" type="image/png" sizes="32x32" href="https://www.ReelCareer.co/images/favicons/favicon-32x32.png">

  <!-- 16x16 Favicon -->
  <link rel="icon" type="image/png" sizes="16x16" href="https://www.ReelCareer.co/images/favicons/favicon-16x16.png">

  <!-- Apple Touch Icon -->
  <link rel="apple-touch-icon" sizes="180x180" href="https://www.ReelCareer.co/images/favicons/apple-touch-icon.png">

  <!-- Android Favicon (192x192) -->
  <link rel="icon" type="image/png" sizes="192x192" href="https://www.ReelCareer.co/images/favicons/android-chrome-192x192.png">

  <!-- Chrome Favicon (512x512) -->
  <link rel="icon" type="image/png" sizes="512x512" href="https://www.ReelCareer.co/images/favicons/android-chrome-512x512.png">

   <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">
<!--
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
-->
  
   <!-- Bootstrap CSS -->
   <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">
    
    <script src="https://reelcareer.co/public/js/scripts.js"></script>
    <script src="https://reelcareer.co/public/js/loadScripts.js"></script>
   
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&family=Montserrat:wght@400;500;700&display=swap" rel="stylesheet">

    <link
    rel="stylesheet"
    href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css"
  />

  <script src="https://cdn.jsdelivr.net/npm/@ffmpeg/ffmpeg@0.10.2/ffmpeg.min.js"></script>

    <link rel="stylesheet" href="https://reelcareer.co/public/css/styles.css">
   
   
   
</head>


<body>
    <script src="https://reelcareer.co/public/js/bodyload.js"></script>
    <nav></nav>


    <nav aria-label="breadcrumb">
      <ol class="breadcrumb">
          <li id="lastBreadcrumb_profile" class="breadcrumb-item"><a href="https://reelcareer.co/u/">Profile</a></li>
          <li id="lastBreadcrumb_messages" class="breadcrumb-item"><a href="https://reelcareer.co/u/messaging">Messages</a></li>
          <li id="lastBreadcrumb_last" class="breadcrumb-item"><a id="lastBreadcrumb_a" href="https://reelcareer.co/u/create">Create Reel</a></li>
          <li id="breadcrumb-active-title" class="breadcrumb-item active" aria-current="page">User</li>
        </ol>
    </nav>

        <style>
          /* General Styles */
          body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;

          }





#mainVideoHolder .video-details {
    display: flex;
    justify-content: space-between;
    width: 100%;
    margin-bottom: 10px;
}

#mainVideoHolder .video-details p {
    margin: 0;
    font-size: 14px;
}

#mainVideoHolder .video-upload-section {
    display: flex;
    justify-content: center;
    width: 100%;
    margin-top: 10px;
}

#mainVideoHolder #uploadButton {
    background-color: #1d72b8;
    color: white;
    border: none;
    padding: 10px;
    font-size: 16px;
    border-radius: 5px;
    cursor: pointer;
}

#mainVideoHolder #uploadButton:hover {
    background-color: #155a8a;
}
#mainVideoHolder {
      position: relative;
      width: 640px;
      height: 360px;
      margin: 20px auto;
      border: 1px solid #ccc;
    }
    #mainVideoHolder  video {
      width: 100%;
      height: 100%;
    }
    #mainVideoHolder  canvas {
      display: none;
    }
    #mainVideoHolder  .draggable {
      cursor: grab;
    }
  main  .hidden {
      display: none;
    }
        </style>
  <!-- Modal styles -->
<style>
  .modal {
    display: none;
    position: fixed;
    z-index: 1;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    overflow: auto;
    background-color: rgba(0, 0, 0, 0.4);
  }
  .modal-content {
    background-color: #fefefe;
    margin: 15% auto;
    padding: 20px;
    border: 1px solid #888;
    width: 80%;
    max-width: 400px;
  }

  main #videoContainer {
  width: 100%;
  display: block;


}


#mainVideoHolder button:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }


main #timelineContainer {
  width: 100%;
  display: block;


}
main #overlayControls {
    width: 100%;
    display: block;
}

/* CSS for showing and hiding modals */
.modal {
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.7);
  z-index: 9999;
  align-items: center;
  justify-content: center;
}

.modal.show {
  display: flex;
}



/* Improved active overlay state */
#mainVideoHolder .active {
  border: 2px solid #4CAF50;
  box-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
  transition: all 0.3s ease-in-out;
}

/* Modal animations */
.modal {
  display: none;
  opacity: 0;
  transition: opacity 0.3s ease;
}

.modal.show {
  display: block;
  opacity: 1;
}

/* Responsive Modal for smaller screens */
@media (max-width: 600px) {
  .modal-content {
    width: 90%;
    padding: 15px;
  }
}

/* Close button on the overlay */
.overlay-close-btn {
  position: absolute;
  top: 5px;
  right: 5px;
  cursor: pointer;
  background-color: #fff;
  border: none;
  font-size: 18px;
}



  .modal-content {
    background-color: #fff;
    padding: 20px;
    margin: 15% auto;
    width: 80%; max-width: 400px;
    text-align: center;
  }


  main .syncedTime {
    color: white;
    text-align: center;
    overflow: hidden;
    font-variant: full-width;
    display: grid;
    align-content: stretch;
    justify-content: space-around;
    align-items: center;
    justify-items: stretch;
}

#mainVideoHolder {
    position: relative;
    width: 100%;
    height: auto;
    background-color: rgb(218 218 218 / 13%);
    overflow: hidden;
    margin: auto;
    right: 0;
    left: 0;
    top: 0;
    bottom: 0;
    border-top-right-radius: 25px;
    border-top-left-radius: 25px;
    display: flex;
    flex-direction: row;
    flex-wrap: nowrap;
    align-content: space-between;
    justify-content: space-around;
    align-items: stretch;
    padding: 2rem;
}
#videoContainer {
  position: relative;
  width: 100%; /* Example size */
  height: 500px;
  overflow: hidden;
  background-color: rgba(0, 0, 0, 0.16);

}

#videoPlayer,
#videoCanvas {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  width: 100%; /* Match videoContainer width */
  height: 100%; /* Match videoContainer height */
  object-fit: contain; /* Default to 'fit' mode */
margin: auto;
}

#mainVideoHolder .actions {
    display: flex;
    justify-content: space-around;
    width: 100%;
    margin-bottom: 10px;
}

#mainVideoHolder .action-btn {
    background: transparent;
    border: none;
    color: white;
    font-size: 24px;
    cursor: pointer;
}

#mainVideoHolder .action-btn:hover {
    color: #1d72b8;
}
#videoBody {
  height: 100%;
  width: 100%;
}

#trashIcon {
margin: auto;
position: absolute;
                bottom: 20px;
                left: 50%;
                transform: translateX(-50%);
                font-size: 40px;
                color: red;
}

.controls {
    width: 100%;
    display: grid;
    align-content: space-between;
    justify-content: center;
    align-items: stretch;
    justify-items: stretch;
}

.controlsGroup {
    width: 100%;
    display: grid;
    align-content: stretch;
    justify-content: space-around;
    align-items: stretch;
    justify-items: stretch;
    gap: 1.5rem;
    -webkit-text-stroke: thin;
    font: icon;
}
#mainVideoHolder .flex {
    display: flex;
    flex-direction: row;
    flex-wrap: wrap;
    align-content: space-between;
    justify-content: space-between;
    align-items: center;
    gap: 2rem;
    width: 100%;
}
.controlsGroup button {
    width: auto;
    padding: 1rem;
    height: 50px;
    min-width: 100px;
}
</style>

<main id="main-content">



  
      <style>
          /* Style for the button */
          #toggleButton {
              margin: 10px 0;
              padding: 10px 20px;
              background-color: #4CAF50;
              color: white;
              border: none;
              border-radius: 5px;
              cursor: pointer;
              font-family: Arial, sans-serif;
          }
          #toggleButton:hover {
              background-color: #45a049;
          }
          /* Style for the Direction Box */
          #directionBox {
              display: none; /* Hidden on load */
              width: auto; 
              padding: 15px; 
              background: #f9f9f9; 
              border: 1px solid #ddd; 
              box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); 
              border-radius: 5px; 
              font-family: Arial, sans-serif;
              margin: 1.5rem; 

          }

          #videoResumeInfomation {
            width: auto; 
            padding: 15px;  
            border: 1px solid #ddd; 
              box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); 
              border-radius: 5px; 
              margin: 1.5rem; 
          }
      </style>

  
  
      <!-- Direction Box -->
      <div id="directionBox">
          <h4 style="margin-top: 0;">How to Use the Video Editor</h4>
          <ul style="list-style-type: square; padding-left: 20px; font-size: 14px;">
              <li><strong>Upload Video</strong>: Click the <em>Upload Video</em> button to load a video file.</li>
              <li><strong>Fit or Cover Mode</strong>:
                  <ul>
                      <li><em>Fit</em>: Adjusts the video to fit the screen while maintaining aspect ratio.</li>
                      <li><em>Cover</em>: Scales the video to cover the screen entirely.</li>
                  </ul>
              </li>
              <li><strong>Audio Options</strong>: 
                  <ul>
                      <li>Use <em>Add Audio</em> to overlay audio on your video.</li>
                  </ul>
              </li>
              <li><strong>Edit Video</strong>:
                  <ul>
                      <li><em>Slice</em>: Trim parts of the video.</li>
                      <li><em>Append</em>: Add other videos or images.</li>
                  </ul>
              </li>
              <li><strong>Overlay Features</strong>:
                  <ul>
                      <li><em>Text Overlay</em>: Add custom text with options for color and size.</li>
                      <li><em>Image Overlay</em>: Add images over the video using a URL.</li>
                  </ul>
              </li>
              <li><strong>Undo/Redo</strong>: Use the <em>Undo</em> and <em>Redo</em> buttons to revert or redo your edits.</li>
              <li><strong>Render and Download</strong>: Once edits are complete, click <em>Render & Download</em> to save the video.</li>
          </ul>
          <p style="font-size: 13px; margin-top: 15px;">
              Need help? <a href="https://reelcareer.co/views/contact" style="color: blue; text-decoration: underline;">Contact Support</a>
          </p>
      </div>
  
      <script>
          // Function to show/hide the direction box
          document.getElementById("toggleButton").addEventListener("click", function () {
              const directionBox = document.getElementById("directionBox");
              if (directionBox.style.display === "none" || directionBox.style.display === "") {
                  directionBox.style.display = "block"; // Show the box
                  this.textContent = "Hide Directions"; // Change button text
              } else {
                  directionBox.style.display = "none"; // Hide the box
                  this.textContent = "Show Directions"; // Change button text
              }
          });
      </script>

  
  <!-- Video Container -->
  <div id="mainVideoHolder" aria-labelledby="mainVideoHolder">

    <!-- left Controls Container -->
    <div class="controls" role="group" aria-labelledby="controls">

        <div class="controlsGroup" role="group" aria-labelledby="controlsGroup">
              <!-- Toggle Button -->
      <button id="toggleButton" aria-label="Toggle Directions">
        <i class="fas fa-info" aria-hidden="true"></i>Show Directions</button>

            <!-- Trigger Button -->
            <button id="uploadButton" aria-label="Upload a video">
                <i class="fas fa-upload" aria-hidden="true"></i> Upload Video
            </button>
        </div>

        <div class="controlsGroup flex" role="group" aria-labelledby="controlsGroup">
            <button id="fitButton" aria-label="Fit video to screen">
                <i class="fas fa-expand-arrows-alt" aria-hidden="true"></i> Fit
            </button>
            <button id="coverButton" aria-label="Cover video to screen">
                <i class="fas fa-arrows-alt" aria-hidden="true"></i> Cover
            </button>
        </div>

        <div class="controlsGroup" role="group" aria-labelledby="Video Slice & Append">
            <!-- Video Slice & Append -->
            <button id="addAudioButton" aria-label="Add audio to video">
                <i class="fas fa-volume-up" aria-hidden="true"></i> Add Audio
            </button>
            <button id="appendVideoButton" aria-label="Append video or image to the video">
                <i class="fas fa-plus-circle" aria-hidden="true"></i> Append Video/Image
            </button>
            <button id="sliceVideoButton" aria-label="Slice the video">
                <i class="fas fa-cut" aria-hidden="true"></i> Slice Video
            </button>
        </div>

    </div>

    <div id="videoContainer" aria-labelledby="videoContainer">
      <div id="videoBody">
        
        <video id="videoPlayer" controls autoplay aria-label="Video player"></video>
        <canvas id="videoCanvas" style="display: none;" aria-hidden="true"></canvas>
</div>
        <!-- Add Trash Can Icon -->
        <i
            id="trashIcon"
            class="fas fa-trash hidden"
           
            aria-label="Delete overlay"
            title="Delete Overlay"
        ></i>
    </div>

    <!-- right Controls Container -->
    <div class="controls" role="group" aria-labelledby="controls">
        <div class="controlsGroup flex" role="group" aria-labelledby="controlsGroup">
            <button id="undoButton" aria-label="Undo last action" title="Undo">
                <i class="fas fa-undo" aria-hidden="true"></i> Undo
            </button>
            <button id="redoButton" aria-label="Redo last action" title="Redo">
                <i class="fas fa-redo" aria-hidden="true"></i> Redo
            </button>
        </div>

        <div class="controlsGroup" role="group" aria-labelledby="controlsGroup">
            <!-- Overlay Controls -->
            <!-- Add Image or Text Overlays -->
            <button id="textOverlayButton" aria-label="Add a text overlay to the video">
                <i class="fas fa-font" aria-hidden="true"></i> Add Text Overlay
            </button>
            <button id="imageButton" aria-label="Add an image overlay to the video">
                <i class="fas fa-image" aria-hidden="true"></i> Add Image Overlay
            </button>
        </div>

        <div class="controlsGroup" role="group" aria-labelledby="controlsGroup">
            <button id="downloadButton" disabled aria-disabled="true" aria-label="Render and download the edited video" title="Render & Download">
                <i class="fas fa-download" aria-hidden="true"></i> Render & Download
            </button>
            <button id="previewVideoSegment" aria-label="Preview the video segment" title="Preview">
                <i class="fas fa-eye" aria-hidden="true"></i> Preview
            </button>
            <button id="postReelButton" disabled aria-disabled="true" aria-label="Upload the edited video" title="Upload">
              <i class="fas fa-upload" aria-hidden="true"></i> Upload
          </button>
        </div>

    </div>

</div>

<div id="timelineDiv" style="position: relative; width: 100%; height: 50px; background: #ddd;">
    <div id="startDiv" class="syncedTime" style="position: absolute; height: 100%; width: 5%; background: black;"></div>
    <div id="stopDiv" class="syncedTime" style="position: absolute; height: 100%; width: 5%; background: red;"></div>
</div>

  <!-- Video Resume Input -->

<div id="videoResumeInfomation" role="group" aria-labelledby="Video Resume Info">

  <div class="mb-3">
    <label for="videoResumeCaption">Video Reel Title </label>
    <input type="text" class="form-control" id="videoResumeCaption" placeholder="My Video Resume Reel, Made with ReelCareer ">

  </div>

<div class="mb-3">
  <label for="tagsSET-resumeTags">Video Tags <small class="text-muted">(Add a tag and press Enter)</small></label>
  <div id="tagsContainertagsSET-resumeTags">
  <input type="text" class="form-control" id="tagsSET-resumeTags" placeholder="(e.g., JavaScript, Management)">
 </div>
</div>
  

</div>



  <!-- Audio Input -->
  <!-- Hidden Video Input -->
  <input type="file" id="videoInput" accept="video/*" class="hidden" aria-label="Select a video to upload" />
  <input type="file" id="audioInput" accept="audio/*" class="hidden" title="Select an audio file to add" aria-label="Select an audio file to add" />




</main>



<!-- Text Overlay Modal -->
<div id="textOverlayModal" class="modal" role="dialog" aria-labelledby="textOverlayModalLabel">
  <div class="modal-content">
    <h3 id="textOverlayModalLabel">Add Text Overlay</h3>
    <input type="text" id="overlayTextInput" placeholder="Enter text" required aria-label="Enter text for overlay" />
    <input type="color" id="textColorInput" value="#ffffff" aria-label="Choose text color" />
    <input type="number" id="fontSizeInput" value="20" min="10" max="100" required aria-label="Choose font size" />
    <select id="fontTypeInput" aria-label="Choose font type">
      <option value="Arial">Arial</option>
      <option value="Verdana">Verdana</option>
      <option value="Tahoma">Tahoma</option>
    </select>
    <button id="saveTextOverlay" aria-label="Save text overlay">Save</button>
  </div>
</div>

<!-- Image Overlay Modal -->
<div id="imageModal" class="modal" role="dialog" aria-labelledby="imageModalLabel">
  <div class="modal-content">
    <h3 id="imageModalLabel">Add Image Overlay</h3>
    <input type="url" id="imageURLInput" placeholder="Enter image URL" aria-label="Enter image URL for overlay" />
    <button id="saveImageOverlay" aria-label="Save image overlay">Save</button>
  </div>
</div>

<!-- Edit Modal -->
<div id="editOverlayModal" class="modal" role="dialog" aria-labelledby="editOverlayModalLabel">
  <div class="modal-content">
    <h3 id="editOverlayModalLabel" class="sr-only">Edit Text Overlay</h3>
    <label for="editTextInput">Text:</label>
    <input type="text" id="editTextInput" aria-label="Edit text for overlay">
    <label for="editColorInput">Color:</label>
    <input type="color" id="editColorInput" aria-label="Edit color for overlay">
    <label for="editFontSizeInput">Font Size:</label>
    <input type="number" id="editFontSizeInput" aria-label="Edit font size for overlay">
    <button id="saveEdit" aria-label="Save changes to overlay">Save Changes</button>
    <button id="closeEditModal" aria-label="Close the edit modal">Cancel</button>
  </div>
</div>
<script>

  
function showUserDataNotFoundMessage() {




  breadcrumbTitleActive.style.display = "none";

lastBreadcrumb_last.style.display = "block";
lastBreadcrumb_a.innerText = "Create a Profile";
lastBreadcrumb_a.href = `https://reelcareer.co/views/auth`;

let mainContainer = document.getElementById('main-content');


  mainContainer.innerHTML = '';

    // Create a container div
    const container = document.createElement('div');
    container.className = 'user-data-not-found-container';
    container.style.cssText = `
        display: flex; 
        justify-content: center; 
        align-items: center; 
        height: 100vh; 
    `;

    // Create the card div
    const card = document.createElement('div');
    card.className = 'user-data-not-found-card';
    card.style.cssText = `
        background-color: white; 
        padding: 20px; 
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1); 
        border-radius: 8px; 
        text-align: center;
    `;

    // Add a title to the card
    const title = document.createElement('h3');
    title.textContent = 'User Not Found Create A Profile';
    title.style.marginBottom = '15px';
    card.appendChild(title);

    // Add a message inside the card
    const message = document.createElement('p');
    message.textContent = 'The requested user could not be found.';
    message.style.marginBottom = '20px';
    card.appendChild(message);

    // Create a "Go Back" button
    const goBackButton = document.createElement('button');
    goBackButton.textContent = 'Go Back';
    goBackButton.className = 'btn btn-primary m-1'; // Assuming Bootstrap classes, if used
    goBackButton.style.padding = '10px 20px';
    
    // Add an event listener to navigate back
    goBackButton.addEventListener('click', () => {
        window.history.back(); // This takes the user to the previous page
    });

    card.appendChild(goBackButton);

    // Create a "Login" button
    const loginButton = document.createElement('button');
    loginButton.textContent = 'Go to Login Page';
    loginButton.className = 'btn btn-primary m-1'; // Assuming Bootstrap classes, if used
    loginButton.style.padding = '10px 20px';

    // Add an event listener to redirect to the login page
    loginButton.addEventListener('click', () => {
        window.location.href = 'https://reelcareer.co/views/auth'; // Change '/login' to your actual login page URL
    });

    card.appendChild(loginButton);

    // Append the card to the container
    container.appendChild(card);

    // Append the container to the body (or a specific element on your page)
    mainContainer.appendChild(container);
}
window.showUserDataNotFoundMessage = showUserDataNotFoundMessage;


      

const lastBreadcrumb_last = document.getElementById("lastBreadcrumb_last");
const lastBreadcrumb_a = document.getElementById("lastBreadcrumb_a");

const breadcrumbTitleActive = document.getElementById("breadcrumb-active-title");


lastBreadcrumb_last.style.display = "none";
breadcrumbTitleActive.style.display = "none";
lastBreadcrumb_a.innerText = "Join Us";
lastBreadcrumb_a.href = `https://reelcareer.co/views/auth`;






</script>
<script>

   // Reference the button and input
   const uploadButton = document.getElementById("uploadButton");
  const videoInput = document.getElementById("videoInput");
  const downloadButton = document.getElementById("downloadButton");
  const addAudioButton = document.getElementById("addAudioButton");
  const audioInput = document.getElementById("audioInput");
  const appendButton = document.getElementById("appendVideoButton");
  const undoButton = document.getElementById("undoButton");
  const redoButton = document.getElementById("redoButton");
  const videoContainer = document.getElementById("videoContainer");

  const videoCanvas = document.getElementById("videoCanvas");
  const ctx = videoCanvas.getContext("2d");

  const videoPlayer = document.getElementById("videoPlayer");
const fitButton = document.getElementById("fitButton");
const coverButton = document.getElementById("coverButton");
const postReelButton = document.getElementById("postReelButton");



    // When the button is clicked, trigger the file input
    uploadButton.addEventListener("click", () => {
      videoInput.click();
    });

// Default video settings on load
window.addEventListener("load", () => {
  setVideoSize("inherit", 500); // Set default container size
  videoPlayer.style.objectFit = "contain"; // Default to 'fit'
});

// Function to set video container and player size
function setVideoSize(width, height) {
  const videoContainer = document.getElementById("videoContainer");
  videoContainer.style.width = `${width}`;
  videoContainer.style.height = `${height}px`;
}

// Event listeners for scaling buttons
fitButton.addEventListener("click", () => {
  videoPlayer.style.objectFit = "contain"; // Fit mode
});

coverButton.addEventListener("click", () => {
  videoPlayer.style.objectFit = "cover"; // Cover mode
});
 

  // Function to set canvas size to match container
function setCanvasSize() {
  videoCanvas.width = videoContainer.offsetWidth;
  videoCanvas.height = videoContainer.offsetHeight;
}

// Set canvas size on load and resize
window.addEventListener("load", setCanvasSize);
window.addEventListener("resize", setCanvasSize);

  let mediaRecorder;
  let recordedChunks = [];
  let textOverlays = [];
  let imageOverlays = [];
  // State and Stacks
  let undoStack = [];
  let redoStack = [];
  let overlays = [];
  let audioURL = null;
  let editedVideoBlob = null;
  let videoURL = null;
  let currentAction = null;
  let startTime = 0; // in seconds
  let stopTime = 5; // in seconds
  // Timeline div elements
  const startDiv = document.getElementById('startDiv');
  const stopDiv = document.getElementById('stopDiv');
  let videoStream = null;
  let offsetX, offsetY; // Offset for drag positioning
  videoInput.addEventListener("change", (e) => {
    const file = e.target.files[0];
    if (file) {
      const url = URL.createObjectURL(file);
      videoPlayer.src = url;
      videoPlayer.load(); // Ensures the video metadata is loaded properly
      videoCanvas.width = videoPlayer.videoWidth || 640;
      videoCanvas.height = videoPlayer.videoHeight || 360;
      downloadButton.disabled = false;
    }
  });

  function renderVideoFrame() {
    ctx.clearRect(0, 0, videoCanvas.width, videoCanvas.height);
    ctx.drawImage(videoPlayer, 0, 0, videoCanvas.width, videoCanvas.height);
    // Render text overlays
    textOverlays.forEach(({
      text,
      x,
      y,
      color,
      fontSize,
      fontFamily
    }) => {
      ctx.fillStyle = color;
      ctx.font = `${fontSize}px ${fontFamily}`;
      ctx.fillText(text, x, y);
    });
    // Render image overlays
    imageOverlays.forEach(({
      image,
      x,
      y,
      width,
      height
    }) => {
      ctx.drawImage(image, x, y, width, height);
    });
    if (videoPlayer.paused || videoPlayer.ended) return; // Stop if video is paused or ended
    requestAnimationFrame(renderVideoFrame);
  }
  downloadButton.addEventListener("click", () => {
    recordedChunks = [];
    mediaRecorder = new MediaRecorder(videoCanvas.captureStream());
    mediaRecorder.ondataavailable = (e) => recordedChunks.push(e.data);
    mediaRecorder.onstop = () => {
      const blob = new Blob(recordedChunks, {
        type: "video/webm"
      });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = `edited-video-${new Date().toISOString()}.webm`;
      a.click();
    };
    mediaRecorder.start();
    videoPlayer.play();
    setTimeout(() => {
      mediaRecorder.stop();
    }, videoPlayer.duration * 1000);
  });
  videoPlayer.addEventListener("play", () => renderVideoFrame());
  // Load Video
  // Add Text Overlay
  document.getElementById("textOverlayButton").addEventListener("click", () => {
    showModal("textOverlayModal");
  });

  const generalTags = createTagInputSystem({
        tagsContainerId: "tagsContainertagsSET-resumeTags",
        badgeClass: "tag-primary" // Custom badge class for general tags
    });

    
  function addOverlay(type) {
    if (type === "text") {
      const text = document.getElementById("overlayTextInput").value;
      const color = document.getElementById("textColorInput").value;
      const fontSize = document.getElementById("fontSizeInput").value + "px";
      const fontFamily = document.getElementById("fontTypeInput").value;
      const overlay = document.createElement("div");
      overlay.textContent = text;
      overlay.style.cssText = `
overlay.style.position = "absolute";
overlay.style.color = color;
overlay.style.fontSize = fontSize;
overlay.style.fontFamily = fontFamily;
overlay.style.top = "10%";
overlay.style.left = "10%";

    `;
      makeDraggable(overlay);
      videoContainer.appendChild(overlay);
      overlays.push(overlay);
      saveActionState("addOverlay", {
        element: overlay
      });
      hideModal("textOverlayModal");
    }
  }

  function previewOverlay(type) {
    const previewContainer = document.getElementById("previewOverlayContainer");
    previewContainer.innerHTML = ''; // Clear previous preview
    if (type === "text") {
      const text = document.getElementById("overlayTextInput").value;
      const color = document.getElementById("textColorInput").value;
      const fontSize = document.getElementById("fontSizeInput").value + "px";
      const fontFamily = document.getElementById("fontTypeInput").value;
      const preview = document.createElement("div");
      preview.textContent = text;
      preview.style.cssText = `
      position: absolute;
      color: ${color};
      font-size: ${fontSize};
      font-family: ${fontFamily};
      top: 10%;
      left: 10%;
    `;
      previewContainer.appendChild(preview);
    }
  }
  // Add event listeners for live preview
  document.querySelectorAll("#overlayTextInput, #textColorInput, #fontSizeInput, #fontTypeInput")
    .forEach((el) => {
      el.addEventListener("input", () => previewOverlay("text"));
    });
  // Add event listener
  document.getElementById("saveTextOverlay").addEventListener("click", () => addOverlay("text"));
  // Add Image Overlay
  document.getElementById("imageButton").addEventListener("click", () => {
    showModal("imageModal");
  });
  // Add Text Overlay
  // Show and hide edit modal
  const editModal = document.getElementById('editOverlayModal');
  const saveEditButton = document.getElementById('saveEdit');
  const closeEditButton = document.getElementById('closeEditModal');
  // Track the active overlay
  let activeOverlay = null;
  // Add Text Overlay
  document.getElementById("saveTextOverlay").addEventListener("click", () => {
    const text = document.getElementById("overlayTextInput").value;
    const color = document.getElementById("textColorInput").value;
    const fontSize = document.getElementById("fontSizeInput").value;
    const overlay = document.createElement("div");
    overlay.textContent = text;
    overlay.style.position = "absolute";
    overlay.style.color = color;
    overlay.style.fontSize = `${fontSize}px`;
    overlay.style.top = "10%";
    overlay.style.left = "10%";
    // Add a unique ID and dataset for easy identification
    overlay.id = `overlay-${Date.now()}`; // Unique ID based on current timestamp
    overlay.dataset.type = 'text';
    overlay.dataset.content = text;
    makeDraggable(overlay);
    videoContainer.appendChild(overlay);
    overlays.push(overlay);
    saveActionState("addOverlay", {
      element: overlay
    });
  });
  // Add Image Overlay
  document.getElementById("saveImageOverlay").addEventListener("click", () => {
    const imageURL = document.getElementById("imageURLInput").value;
    const img = document.createElement("img");
    img.src = imageURL;
    img.style.position = "absolute";
    img.style.width = "100px";
    img.style.top = "10%";
    img.style.left = "10%";
    // Add a unique ID and dataset for easy identification
    img.id = `overlay-${Date.now()}`; // Unique ID based on current timestamp
    img.dataset.type = 'image';
    img.dataset.src = imageURL;
    makeDraggable(img);
    videoContainer.appendChild(img);
    overlays.push(img);
    saveToUndo("addOverlay", img);
    hideModal("imageModal");
  });
  // Handle editing of overlays
  function makeDraggable(overlay) {
    overlay.classList.add("draggable");
    overlay.setAttribute("draggable", true);
    overlay.addEventListener("dragstart", (e) => {
      draggedOverlay = overlay;
      setTimeout(() => {
        overlay.style.opacity = "0.5"; // Fade the overlay when dragging starts
      }, 0);
      const offsetX = e.clientX - overlay.getBoundingClientRect().left;
      const offsetY = e.clientY - overlay.getBoundingClientRect().top;
      overlay.dataset.offsetX = offsetX;
      overlay.dataset.offsetY = offsetY;
    });
    overlay.addEventListener("dragend", () => {
      setTimeout(() => {
        draggedOverlay.style.opacity = "1";
        draggedOverlay = null;
      }, 0);
    });
    overlay.addEventListener("drag", (e) => {
      if (draggedOverlay) {
        const offsetX = parseFloat(draggedOverlay.dataset.offsetX);
        const offsetY = parseFloat(draggedOverlay.dataset.offsetY);
        const x = e.clientX - videoContainer.offsetLeft - offsetX;
        const y = e.clientY - videoContainer.offsetTop - offsetY;
        draggedOverlay.style.left = `${x}px`;
        draggedOverlay.style.top = `${y}px`;
        if (y + draggedOverlay.offsetHeight > videoContainer.offsetHeight - 50) {
          trashIcon.classList.remove("hidden");
        } else {
          trashIcon.classList.add("hidden");
        }
      }
    });
    overlay.addEventListener("dragover", (e) => {
      e.preventDefault(); // Enable drop
    });
    overlay.addEventListener("drop", (e) => {
      if (draggedOverlay) {
        const overlayRect = draggedOverlay.getBoundingClientRect();
        const trashRect = trashIcon.getBoundingClientRect();
        if (overlayRect.bottom >= trashRect.top && overlayRect.top <= trashRect.bottom) {
          videoContainer.removeChild(draggedOverlay); // Remove the overlay
        }
        trashIcon.classList.add("hidden");
      }
    });
    // Add click listener to mark the overlay as active and open the edit modal
    overlay.addEventListener("click", (e) => {
      e.stopPropagation(); // Prevent the parent click event from triggering
      // Set overlay as active
      if (activeOverlay) {
        activeOverlay.classList.remove('active'); // Remove previous active state
      }
      overlay.classList.add('active');
      activeOverlay = overlay;
      // Open the edit modal
      openEditModal(overlay);
    });
  }
  // Open the Edit Modal and populate it with current overlay data
  // Open the edit modal with real-time updates
  function openEditModal(overlay) {
    if (overlay.dataset.type === "text") {
      document.getElementById("editTextInput").value = overlay.dataset.content;
      document.getElementById("editColorInput").value = overlay.style.color;
      document.getElementById("editFontSizeInput").value = parseInt(overlay.style.fontSize);
    }
    editModal.classList.add('show'); // Show the modal with animation
    // Set focus to the first input field when modal is opened
    document.getElementById("editTextInput").focus();
  }
  // Save the edited overlay with real-time feedback
  saveEditButton.addEventListener("click", () => {
    if (activeOverlay) {
      const text = document.getElementById("editTextInput").value;
      const color = document.getElementById("editColorInput").value;
      const fontSize = document.getElementById("editFontSizeInput").value;
      if (activeOverlay.dataset.type === "text") {
        activeOverlay.textContent = text;
        activeOverlay.style.color = color;
        activeOverlay.style.fontSize = `${fontSize}px`;
        activeOverlay.dataset.content = text;
      }
      editModal.classList.remove('show'); // Hide modal with animation
    }
  });
  // Close edit modal without saving
  closeEditButton.addEventListener("click", () => {
    editModal.style.display = "none"; // Hide modal
    if (activeOverlay) {
      activeOverlay.classList.remove('active'); // Remove active state
    }
  });
  // Close the modal if clicked outside of it
  window.addEventListener('click', (e) => {
    if (e.target === editModal) {
      editModal.style.display = "none";
      if (activeOverlay) {
        activeOverlay.classList.remove('active');
      }
    }
  });
  // Undo/Redo Functionality
  function saveToUndo(action, data) {
    undoStack.push({
      action,
      data
    });
    redoStack = []; // Clear redo stack on new action
    // Limit the undo stack size to 50 actions
    if (undoStack.length > 50) {
      undoStack.shift(); // Remove the oldest action to maintain a fixed size
    }
  }

  function showBeforeAfter(prevSrc, newSrc) {
    const beforeVideo = document.getElementById("beforeVideo");
    const afterVideo = document.getElementById("afterVideo");
    beforeVideo.src = prevSrc;
    afterVideo.src = newSrc;
  }
  // Update Undo/Redo to call comparison
  function saveActionState(actionType, actionData) {
    const state = {
      action: actionType,
      data: actionData
    };
    undoStack.push(state);
    redoStack = []; // Clear redo stack on new action
    toggleUndoRedo(); // Update button states
    // Update before/after view if needed
    if (actionData.prevVideoSrc && actionData.newVideoSrc) {
      showBeforeAfter(actionData.prevVideoSrc, actionData.newVideoSrc);
    }
  }
  // Helper Function: Toggle Undo/Redo Buttons
  function toggleUndoRedo() {
    undoButton.disabled = undoStack.length === 0;
    redoButton.disabled = redoStack.length === 0;
    undoButton.title = undoStack.length ? "Undo Last Action" : "Nothing to Undo";
    redoButton.title = redoStack.length ? "Redo Last Action" : "Nothing to Redo";
  }
  // Function: Undo Action
  function undoAction() {
    if (undoStack.length > 0) {
      const {
        action,
        data
      } = undoStack.pop();
      switch (action) {
        case "addOverlay":
          data.element.remove();
          overlays = overlays.filter((el) => el !== data.element);
          break;
        case "moveOverlay":
          data.element.style.left = data.prevX;
          data.element.style.top = data.prevY;
          break;
        case "addAudio":
          videoPlayer.src = data.prevVideoSrc; // Revert to previous video
          break;
        case "sliceVideo":
        case "appendMedia":
          videoPlayer.src = data.prevVideoSrc; // Revert video modification
          break;
      }
      redoStack.push({
        action,
        data
      });
      toggleUndoRedo();
    }
  }
  // Function: Redo Action
  function redoAction() {
    if (redoStack.length > 0) {
      const {
        action,
        data
      } = redoStack.pop();
      switch (action) {
        case "addOverlay":
          videoContainer.appendChild(data.element);
          overlays.push(data.element);
          break;
        case "moveOverlay":
          data.element.style.left = data.newX;
          data.element.style.top = data.newY;
          break;
        case "addAudio":
          mergeAudioWithVideo(data.audioSrc);
          break;
        case "sliceVideo":
        case "appendMedia":
          videoPlayer.src = data.newVideoSrc; // Re-apply video modification
          break;
      }
      undoStack.push({
        action,
        data
      });
      toggleUndoRedo();
    }
  }
  // Event Listeners
  undoButton.addEventListener("click", undoAction);
  redoButton.addEventListener("click", redoAction);
  // Modal Helpers
  function showModal(modalId) {
    const modal = document.getElementById(modalId);
    modal.classList.add("show");
    modal.setAttribute("aria-hidden", "false");
    modal.querySelector("input, button").focus(); // Focus first input/button for accessibility
  }

  function hideModal(modalId) {
    const modal = document.getElementById(modalId);
    modal.classList.remove("show");
    modal.setAttribute("aria-hidden", "true");
  }
</script>

<script>
  // Add Audio to Video
  // Add Audio to Video
  addAudioButton.addEventListener("click", () => {
    audioInput.click();
  });
  audioInput.addEventListener("change", (e) => {
    const audioFile = e.target.files[0];
    if (audioFile) {
      const audioURL = URL.createObjectURL(audioFile);
      const audioPreview = new Audio(audioURL);
      // Display audio preview controls
      const audioPreviewContainer = document.getElementById("audioPreviewContainer");
      audioPreviewContainer.innerHTML = `<audio controls><source src="${audioURL}" type="audio/mp3"></audio>`;
      // Optional: Automatically merge audio with video if the user confirms.
      audioPreview.oncanplaythrough = () => {
        mergeAudioWithVideo(audioURL);
        saveActionState("addAudio", {
          audioSrc: audioURL
        });
      };
    }
  });
    // Append Video or Image
    appendButton.addEventListener("click", () => {
    const fileInput = document.createElement("input");
    fileInput.type = "file";
    fileInput.accept = "video/*,image/*";
    fileInput.onchange = (e) => {
      const file = e.target.files[0];
      if (file) {
        appendMedia(URL.createObjectURL(file), file.type.startsWith("video"));
        saveActionState("appendMedia");
      }
    };
    fileInput.click();
  });

  function appendMedia(mediaSrc, isVideo) {
    const media = document.createElement(isVideo ? "video" : "img");
    media.src = mediaSrc;
    media.style.width = "100%";
    media.style.marginTop = "10px";
    document.getElementById("videoContainer").appendChild(media);
  }
  async function mergeAudioWithVideo(audioSrc) {
    const audio = new Audio(audioSrc);
    const stream = videoPlayer.captureStream();
    const audioStream = audio.captureStream();
    await audio.play(); // Ensure audio starts playing before recording
    const combinedStream = new MediaStream([...stream.getTracks(), ...audioStream.getAudioTracks()]);
    const mediaRecorder = new MediaRecorder(combinedStream);
    const chunks = [];
    return new Promise((resolve) => {
      mediaRecorder.ondataavailable = (e) => chunks.push(e.data);
      mediaRecorder.onstop = () => {
        const blob = new Blob(chunks, {
          type: "video/webm"
        });
        const mergedURL = URL.createObjectURL(blob);
        videoPlayer.src = mergedURL;
        resolve(mergedURL);
      };
      mediaRecorder.start();
      setTimeout(() => mediaRecorder.stop(), videoPlayer.duration * 1000);
    });
  }







  // Event listener for start time
  startDiv.addEventListener("mousedown", (e) => {
    const timeline = document.getElementById('timelineDiv');
    const timelineWidth = timeline.offsetWidth;
    const startDivWidth = startDiv.offsetWidth;
    // Calculate the offset of the center of the div
    const offsetX = e.clientX - startDiv.offsetLeft - startDivWidth / 2;
    // Position the startDiv by its center initially
    startDiv.style.position = 'absolute';
    const onMouseMove = (e) => {
      // Calculate the new left position of the startDiv, ensuring it moves within the bounds of the timeline
      let newLeft = e.clientX - offsetX;
      newLeft = Math.max(0, Math.min(newLeft, timelineWidth - startDivWidth));
      // Update startTime based on mouse position
      startTime = Math.min((newLeft / timelineWidth) * videoPlayer.duration, stopTime);
      updateStartDiv();
      updateSyncedTime(startDiv, startTime); // Update synced time on the start div
    };
    const onMouseUp = () => {
      document.removeEventListener("mousemove", onMouseMove);
      document.removeEventListener("mouseup", onMouseUp);
    };
    document.addEventListener("mousemove", onMouseMove);
    document.addEventListener("mouseup", onMouseUp);
  });
  // Event listener for stop time
  stopDiv.addEventListener("mousedown", (e) => {
    const timeline = document.getElementById('timelineDiv');
    const timelineWidth = timeline.offsetWidth;
    const stopDivWidth = stopDiv.offsetWidth;
    // Calculate the offset of the center of the div
    const offsetX = e.clientX - stopDiv.offsetLeft - stopDivWidth / 2;
    // Position the stopDiv by its center initially
    stopDiv.style.position = 'absolute';
    const onMouseMove = (e) => {
      // Calculate the new left position of the stopDiv, ensuring it moves within the bounds of the timeline
      let newLeft = e.clientX - offsetX;
      newLeft = Math.max(0, Math.min(newLeft, timelineWidth - stopDivWidth));
      // Update stopTime based on mouse position
      stopTime = Math.max((newLeft / timelineWidth) * videoPlayer.duration, startTime + 1);
      updateStopDiv();
      updateSyncedTime(stopDiv, stopTime); // Update synced time on the stop div
    };
    const onMouseUp = () => {
      document.removeEventListener("mousemove", onMouseMove);
      document.removeEventListener("mouseup", onMouseUp);
    };
    document.addEventListener("mousemove", onMouseMove);
    document.addEventListener("mouseup", onMouseUp);
  });
  // Update the timeline divs for start and stop times
  function updateStartDiv() {
    const timelineWidth = document.getElementById('timelineDiv').offsetWidth;
    startDiv.style.left = `${(startTime / videoPlayer.duration) * timelineWidth}px`;
    startDiv.innerText = (Math.round(startTime * 1000) / 1000).toFixed(3);

  }

  function updateStopDiv() {
    const timelineWidth = document.getElementById('timelineDiv').offsetWidth;
    stopDiv.style.left = `${(stopTime / videoPlayer.duration) * timelineWidth}px`;
    stopDiv.innerText = (Math.round(stopTime * 1000) / 1000).toFixed(3);
  }
  // Function to update synced time at the center of the div
  function updateSyncedTime(div, time) {
    const syncedTimeDisplay = div.querySelector('.syncedTime');
    if (syncedTimeDisplay) {
      syncedTimeDisplay.textContent = formatTime(time); // Display formatted time at the center
    }
  }
  // Helper function to format time (in seconds)
  function formatTime(timeInSeconds) {
    const minutes = Math.floor(timeInSeconds / 60);
    const seconds = Math.floor(timeInSeconds % 60);
    return `${minutes}:${seconds < 10 ? '0' + seconds : seconds}`;
  }
  // Function to slice the video and create a blob
  function sliceVideo() {
    const videoFile = videoPlayer.src; // Your video URL
    const mediaSource = new MediaSource();
    // Attach the MediaSource to the video player
    videoPlayer.src = URL.createObjectURL(mediaSource);
    mediaSource.addEventListener('sourceopen', function() {
      const sourceBuffer = mediaSource.addSourceBuffer('video/webm; codecs="vp8"');
      // Fetch the video data as an ArrayBuffer (for slicing purposes)
      fetch(videoFile)
        .then(response => response.arrayBuffer())
        .then(buffer => {
          const videoData = new Uint8Array(buffer);
          // Calculate start and stop byte positions based on video duration
          const startByte = Math.floor((startTime / videoPlayer.duration) * videoData.length);
          const stopByte = Math.floor((stopTime / videoPlayer.duration) * videoData.length);
          // Slice the video data between startByte and stopByte
          const slicedData = videoData.slice(startByte, stopByte);
          // Append the sliced data to the source buffer
          sourceBuffer.appendBuffer(slicedData);
          // Once the buffer is appended, signal the video to play the sliced segment
          sourceBuffer.addEventListener('updateend', () => {
            mediaSource.endOfStream(); // End the stream
            videoPlayer.play(); // Start playing the sliced video
          });
        })
        .catch(error => {
          console.error('Error fetching video data:', error);
        });
    });
  }

  function previewVideoSegment() {
    const video = videoPlayer;
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    // Set canvas size to match the video resolution
    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;
    // Seek to the start time of the segment
    video.currentTime = startTime;
    video.addEventListener('seeked', function() {
      // Capture the frame when the video reaches the start time
      ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
      // Optionally display this frame in an image element
      const image = new Image();
      image.src = canvas.toDataURL(); // Convert the canvas content to an image URL
      document.body.appendChild(image); // Show the captured frame on the page
      // Continue playing video and update canvas to show frames
      video.play();
    });
  }
  // Function to capture a frame from the video and render it on the canvas
  function renderVideoFrame() {
    ctx.clearRect(0, 0, videoCanvas.width, videoCanvas.height);
    ctx.drawImage(videoPlayer, 0, 0, videoCanvas.width, videoCanvas.height);
    if (videoPlayer.paused || videoPlayer.ended) return; // Stop if video is paused or ended
    requestAnimationFrame(renderVideoFrame);
  }
  // Add Event Listener to the slice button to trigger video slicing
  document.getElementById("sliceVideoButton").addEventListener("click", sliceVideo);
  document.getElementById("previewVideoSegment").addEventListener("click", previewVideoSegment);
  // Render the frame when video is playing
  videoPlayer.addEventListener("play", () => {
    renderVideoFrame();
  });







 
    // Log the selected file (optional: for debugging)
    videoInput.addEventListener("change", (event) => {
      const file = event.target.files[0];
      if (file) {
        console.log("Selected video file:", file.name);
      }
    });








  // Update start and stop times with the timeline on play
  videoPlayer.addEventListener("timeupdate", () => {
    if (videoPlayer.currentTime >= startTime && videoPlayer.currentTime <= stopTime) {
      // Sync video current time with the timeline divs
      updateStartDiv();
      updateStopDiv();
    }
  });
  toggleUndoRedo();


    function checkMobileView() {
  // Get the window width
  const windowWidth = window.innerWidth;

  // Select all buttons inside the div with the id 'mainVideoHolder'
  const buttons = document.querySelectorAll('.controlsGroup button');

  // Loop through each button
  buttons.forEach(button => {
    // Check if the window is in mobile view (you can adjust the width threshold as needed)
    if (windowWidth <= 768) { // Mobile view threshold (you can change this)
      // Hide the text inside the button, but keep the <i> tags
      const text = button.querySelectorAll(':not(i)');
      text.forEach(el => el.style.display = 'none');
    } else {
      // If not in mobile view, show the text again
      const text = button.querySelectorAll(':not(i)');
      text.forEach(el => el.style.display = '');
    }
  });
}

// Call the function when the window is resized or loaded
window.addEventListener('resize', checkMobileView);
window.addEventListener('load', checkMobileView);

</script>























    <!-- Footer -->
    <footer id="dynamic-footer"></footer>
    
    <!-- Firebase configuration/ Login& Out -->
    <script type="module" src="https://reelcareer.co/public/js/main.js"></script> 

   
    

    <!-- Firebase JS SDK and Custom Scripts -->

    <script type="module">
      import {
        db, getStorage, ref, uploadBytes, getDownloadURL, limit,
  doc, arrayUnion, RecaptchaVerifier, increment, getDoc, arrayRemove, signInWithPhoneNumber,
  query, updateDoc, setDoc, addDoc, signInAnonymously, orderBy, onAuthStateChanged,
  uploadBytesResumable, signInWithPopup, FacebookAuthProvider, GoogleAuthProvider, startAfter,
  OAuthProvider, signOut, deleteDoc, getFirestore, serverTimestamp,
  createUserWithEmailAndPassword, signInWithEmailAndPassword, deleteObject,
  where, getDocs, storage, getAuth, collection, auth, analytics,
  googleProvider,onSnapshot ,
  facebookProvider,
  getUserId // Export the function
    } from 'https://reelcareer.co/js/module.js';




    let userId;

// Retrieve and populate form inputs for tabs
window.onload = async function () {
  userId = await getUserId(); // Await here to properly set userId
    const userDataSaved = getUserData() || [];


    setTimeout(() => {


        console.log("Module User We outside:", userId);
        console.log("userDataSaved We outside:", userDataSaved);

        // Ensure userIdFromURL is not null or undefined
    if (!userId) {
      // Call this function when the user data is not found
      showUserDataNotFoundMessage();
            console.log("No user session.");

            return;
        }else{


          
const breadcrumbTitleActive = document.getElementById("breadcrumb-active-title");




breadcrumbTitleActive.innerText = userDataSaved.displayName;
// Set the new title
document.title = `ReelCareer.co | ${userDataSaved.displayName} Create Reel`;

breadcrumbTitleActive.style.display = "block";
        }



        // Check if the tags array is defined and has elements
if (!userDataSaved.tags || userDataSaved.tags.length === 0) {
    // If there are no tags, display a message
} else {
    // Directly use the tags array since it contains strings
    const tags = userDataSaved.tags; // No need to map since they're already strings
    

const tagsContainer = document.getElementById('tagsList');
userDataSaved.tags.forEach(tag => {
              const tagElement = document.createElement('div');
              tagElement.className = 'tag';
              tagElement.innerHTML = `<span class="tag badge tag-primary mr-1">
                ${tag}<button class="ml-1 btn btn-sm tag"> x</button></span>`;
              tagsContainer.appendChild(tagElement);
          });
}

  
    }, 300);
};




    async function uploadVideoResume(userID, videoData) {
    try {
        // Ensure 'storage' is properly initialized
        const storageInstance = getStorage(); // Use Firebase's getStorage method

        
        // Create a storage reference dynamically based on conversationID and file name
        const fileRef = ref(storageInstance, `videoResumes/${userID}/${videoData.name}`);

        // Upload the file to Firebase Storage
        const snapshot = await uploadBytes(fileRef, videoData.file);

        // Get the download URL for the uploaded file
        return await getDownloadURL(snapshot.ref);
    } catch (error) {
        console.error("Error uploading video resume:", error);
        throw new Error('Failed to upload video resume.'); // Handle this in calling function
    }
}

window.uploadVideoResume = uploadVideoResume;



async function postReelFunction() {
    let videoResumeURL = '';
      // Fetch required data
      const userID = auth.currentUser.uid;

    const userDataSaved = getUserData() || [];

    console.log("userID: ", userID);
    console.log("userDataSaved: ", userDataSaved);

    if (!userIdFromURL && !userID) {
      showToast('No User Info');

      return;
    } 
 



    return;
    const videoResumeCaptions = document.getElementById('videoResumeCaption').value.trim();
    // Ensure tagsList is not empty or null
    const tagsInput = document.getElementById('tagsSET-resumeTags').value.trim();
    const tags = tagsInput ? tagsInput.split(",").map(item => item.toLowerCase().trim()) : [];

    // Check if there's at least one comma
    const hasComma = tagsInput.includes(',');
    if (!hasComma) {
        showToast("Please add at least Two (2) tags.");
        return;  // Prevent form submission if validation fails
    }


    try {

      mediaRecorder = new MediaRecorder(videoCanvas.captureStream());
    mediaRecorder.ondataavailable = (e) => recordedChunks.push(e.data);
    mediaRecorder.onstop = () => {
      const blob = new Blob(recordedChunks, {
        type: "video/webm"
      });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = `edited-video-${new Date().toISOString()}.webm`;
    };


  const videoData = {
    duration: videoPlayer.duration,
    name: `${userID}-${new Date().toISOString()}-reel.${fileType}`,
    file: url,
    fileType: "",
  
      };

      


            // Upload the attachment and get its URL
            videoResumeURL = await uploadVideoResume(userID, videoResumeFile);
        } catch (error) {
            console.error('Attachment upload failed:', error);
            showToast('Failed to upload video resume. Please try again.',"error");
            return; // Stop form submission on failure
        }
        

    // Gather videoResumeData
    const videoResumeData = {
        userID: userDataSaved.userId || '',

        displayName: userDataSaved.displayName || '',
        publicProfile: userDataSaved.publicProfile  || true,
        profilePicture: userDataSaved.profilePicture || '',
        profileURL: `https://reelcareer.co/u/?u=${userId}`,
        membershipType: userDataSaved.membershipType || 'free',

        
        position:  userDataSaved.position || '',
        tags: tags,
        videoResumeCaptions,

        videoResumeFileName: videoResumeFile ? videoResumeFile.name : '',
        videoResumeURL,

        name:  videoData.name || '',
        duration:  videoData.duration || '',
        fileType:  videoData.fileType || '',

        createdAt: new Date(),
        timestamp: serverTimestamp(),

        views: 0,
        shares: 0,
        likes: 0,
        loves: 0,

        status: 'posted',
        isDeleted: false,



      };

    console.log("User Data:", userData);

    try {
        const userDataSaved = await getUserData() || {};

        const reelDocRef = doc(db, "VideoResumes");
        await addDoc(reelDocRef, videoResumeData);

        let reelID =  docID;

        const vidResumeData = {
        reelID: reelID,
        videoResumeURL,
        createdAt: new Date(),
        status: 'posted',
      };

      const userDocRef = doc(db, "Users",  userDataSaved.userID);
        await setDoc(userDocRef, { vidResumeData: vidResumeData }, { merge: true });

        const userDataEcode = setUserData(vidResumeData);

        localStorage.setItem('userData', userDataEcode);

        console.log("Your Resume Reel have been posted successfully!");

        loadUserData(userData);

        showMessageAndFadeBtn('postReelButton', "Posted");

        showToast("Your Resume Reel have been posted successfully.","success");

        showToast(
  "Your Resume Reel have been posted successfully. @[Video Resume]",
  "success",
  10000,
  `https://reelcareer.co/reels#${reelID}`
);
    } catch (error) {
        console.error("Error saving user data:", error.message);
        showToast("There was an error posting you resume reel. Please try again later.");
    }



  }
window.postReelFunction = postReelFunction;

  postReelButton.addEventListener("click", postReelFunction);





   

function setBlogMetaTags(blogData) {
    // Update the document title
    document.title = `ReelCareer.co | Blog: ${blogData.title}`;

    // Helper function to create or update a meta tag
    function updateMetaTag(name, content, property = false) {
        let meta = document.querySelector(property ? `meta[property="${name}"]` : `meta[name="${name}"]`);
        if (!meta) {
            meta = document.createElement('meta');
            if (property) {
                meta.setAttribute('property', name);
            } else {
                meta.setAttribute('name', name);
            }
            document.head.appendChild(meta);
        }
        meta.setAttribute('content', content);
    }

    // Meta tags for SEO
    updateMetaTag('description', blogData.description || 'Read this insightful blog on ReelCareer.co!');
    updateMetaTag('keywords', blogData.keywords || 'ReelCareer, blog, career, jobs');
    updateMetaTag('author', blogData.author || 'ReelCareer Team');

    // Open Graph (OG) meta tags for social media sharing
    updateMetaTag('og:title', `ReelCareer.co | Blog: ${blogData.title}`, true);
    updateMetaTag('og:description', blogData.description || 'Discover this blog post on ReelCareer.co!', true);
    updateMetaTag('og:image', blogData.image || 'https://reelcareer.co/images/default-blog-thumbnail.png', true);
    updateMetaTag('og:url', blogData.url || window.location.href, true);
    updateMetaTag('og:type', 'article', true);

    // Twitter card meta tags
    updateMetaTag('twitter:card', 'summary_large_image');
    updateMetaTag('twitter:title', `ReelCareer.co | Blog: ${blogData.title}`);
    updateMetaTag('twitter:description', blogData.description || 'Check out this blog post on ReelCareer!');
    updateMetaTag('twitter:image', blogData.image || 'https://reelcareer.co/images/default-blog-thumbnail.png');
}











    </script>


    
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>
